var aemi = (function (exports) {
    'use strict';

    /* eslint-env module */

    /**
     * Get globalThis object in any scope
     * @returns {globalThis} The globalThis object
     */
    function getGlobal$1() {
        return globalThis || self || window || global;
    }

    /**
     * Test if in Browser Environment
     * @returns {Boolean}
     */
    function isBrowser() {
        return typeof window !== 'undefined' || typeof self !== 'undefined';
    }

    /**
     * Test if in Node Environment
     * @returns {Boolean}
     */
    function isNode() {
        return typeof process !== 'undefined' && process.versions && process.versions.node && typeof module === 'object';
    }

    /**
     * Test if in standard Web Worker Environment
     * @returns {Boolean}
     */
    function isWorker() {
        const _global = getGlobal$1();
        return !( 'document' in _global && typeof _global.document !== 'undefined' );
    }

    /**
     * @callback callback
     * @param {String} key - Entry's key
     * @param {any} value - Entry's value
     * @param {Number} index - Entry's index
     * @param {Object} object - Object passed to callback
     */
    /**
     * Apply a function to each entry of an object
     * @param {Object} object - Object to iterate over its entries
     * @param {callback} func - Function to apply over each entry of passed object
     * @returns {void}
     */
    function objectForEach( object, func ) {
        let index = 0;
        for ( const key in object ) {
            if ( Object.prototype.hasOwnProperty.call( object, key ) ) {
                func( key, object[key], index++, object );
            }
        }
    }

    /**
     * @callback callback
     * @param {String} key - Entry's key
     * @param {any} value - Entry's value
     * @param {Number} index - Entry's index
     * @param {Object} object - Object passed to callback
     */
    /**
     * Apply a function to each entry of an object
     * @param {Object} object - Object to iterate over its entries
     * @param {callback} func - Function to apply over each entry of passed object
     * @returns {Object}
     */
    function objectMap( object, func ) {
        const newObject = {};
        let index = 0;
        for ( const key in object ) {
            if ( Object.prototype.hasOwnProperty.call( object, key ) ) {
                newObject[key] = func( key, object[key], index++, object );
            }
        }
        return newObject;
    }

    /**
     * Retrieve a unique identifier
     *
     * @param {Number} length - Length of identifier to return
     * @returns {String} Unique Identifier
     */
    function newUID( length = 16 ) {
        /**
         * @param {Number} number
         * @returns {String}
         */
        function intToChar( number ) {
            const abs = number < 0 ? -number : number;
            const mod = abs % 62;
            if ( mod < 10 ) {
                return String.fromCharCode( 48 + mod );
            }
            else if ( mod < 36 ) {
                return String.fromCharCode( 65 + mod - 10 );
            }
            return String.fromCharCode( 97 + mod - 36 );

        }
        const src = new Uint8Array( length );
        window.crypto.getRandomValues( src );
        return Array( length )
            .fill( 0 )
            .map( ( _, i ) => intToChar( src[i] ) )
            .join( '' );
    }

    /**
     * Remove starting slashes
     *
     * @param {string} path
     * @returns {string}
     */
    function removeStartingSlash( path ) {
        return `${ path.replace( /^\/*/gu, '' ) }`;
    }

    /**
     * Remove trailing slashes
     *
     * @param {string} path
     * @returns {string}
     */
    function removeTrailingSlash( path ) {
        return `${ path.replace( /\/*$/gu, '' ) }`;
    }

    /**
     * Remove starting and trailing slashes
     *
     * @param {string} path
     * @returns
     */
    function removeBothSlashes( path ) {
        return `${ path.replace( /(?:^\/*|\/*$)/gu, '' ) }`;
    }

    /**
     * Get last path element without path nor extension
     *
     * @param {string} path - Path to file
     * @returns {string}
     */
    function getLastPath( path ) {
        return path
            .split( /\//gu )
            .pop()
            .split( /\./gu )
            .filter( str => str.length > 0 )
            .shift();
    }

    var utils = {
        getGlobal: getGlobal$1,
        getLastPath,
        isBrowser,
        isNode,
        isWorker,
        newUID,
        objectForEach,
        objectMap,
        removeBothSlashes,
        removeStartingSlash,
        removeTrailingSlash
    };

    /* eslint-env module */

    class ExtendedWorkerHandler {

        /**
         * @typedef {Object} ExtendedWorkerListenerOptions
         * @property {boolean} keepMessageEvent
         * @property {string} propertyAccessor
         */

        /**
         * @typedef {ExtendedWorkerHandler & Proxy} ExtendedWorkerHandlerProxy
         */

        constructor() {
            this.typeListeners = {};
            this.addTypeListener( 'default', value => value );
            this.self.onmessage = message => this.listen( message );
            this.self._ = this.proxy;
        }

        /**
         * @returns {globalThis}
         */
        // eslint-disable-next-line class-methods-use-this
        get self() {
            return globalThis || window;
        }

        /**
         * @returns {ExtendedWorkerHandlerProxy}
         */
        get proxy() {
            return new Proxy( this, {
                get: ( target, property ) => {
                    if ( property in target ) {
                        return target[property];
                    }
                    return ( func, options ) => target.addTypeListener( property, func, options || { propertyAccessor: 'data' } );
                }
            } );
        }

        /**
         * @param {MessageEvent} messageEvent
         * @returns {void}
         */
        listen( messageEvent ) {
            const { id, data } = messageEvent.data;
            if ( typeof data === 'object' && 'type' in data ) {
                if ( data.type in this.typeListeners ) {
                    this.typeListeners[data.type]( id, data, messageEvent );
                }
                else {
                    this.typeListeners.default( id, data, messageEvent );
                }
            }
            else {
                this.typeListeners.default( id, data, messageEvent );
            }
        }

        /**
         * @param {String} type - Message Type to look for when receiving a message
         * @param {Function} func - Message Handler to call
         * @param {ExtendedWorkerListenerOptions} [options] - Options used to parse message data
         * @returns {void}
         */
        addTypeListener( type, func, options = {} ) {
            const { keepMessageEvent, propertyAccessor } = options;
            this.typeListeners[type] = ( id, data, messageEvent ) => {
                const _data = propertyAccessor ? data[propertyAccessor] : data;
                const _args = keepMessageEvent ? [ messageEvent, _data ] : [ _data ];
                const _value = func( ..._args );
                if ( _value instanceof Promise ) {
                    _value.then( value => {
                        this.self.postMessage( { id, data: value } );
                    } ).catch( console.error );
                }
                else {
                    this.self.postMessage( { id, data: _value } );
                }
            };
        }

    }


    class ExtendedWorker {

        /**
         * @typedef {Object} ExtendedWorkerOptions
         * @property {Boolean} [promise] - Whether to return a Promise from ExtendedWorker.postMessage
         * @property {String|String[]} [importScripts] - Third-party Scripts to import into the Worker
         * @property {Boolean} [includeHandler] - Whether to include the default ExtendedWorkerHandler in the worker
         * @property {String|String[]} [localImports] - Local Scripts to import into the Worker
         * @property {Boolean} [uglify] - Wrap your function in importScripts
         * @property {"include"|"omit"|"same-origin"} [credentials] - Whether to send credentials with requests
         * @property {String} [name] - Name of the worker
         * @property {"classic"|"module"} [type] - Type of the worker
         */

        /**
         * @typedef {Object} ExtendedWorkerPromiseManager
         * @property {Object.<string,Function>} resolves
         * @property {Object.<string,Function>} rejects
         * @property {number} instances
         */

        /**
         * @typedef {ExtendedWorker & Proxy} ExtendedWorkerProxy
         */

        /**
         * @typedef {[any,Transferable[]?]} WorkerMessagePayload
         */

        static {
            this.resolves = {};
            this.rejects = {};
            this.instances = 0;
        }

        /**
         * @returns {number}
         */
        static get id() {
            return ExtendedWorker.instances++;
        }

        /**
         * Post Message to Worker within an ExtendedWorker
         * @param {WorkerMessagePayload} messagePayload - Message Payload to pass through Worker.postMessage
         * @param {ExtendedWorker} worker - Worker to which post messagePayload
         * @returns {void|Promise}
         */
        static postMessage( messagePayload, extendedWorker ) {
            const { worker, promise, id, usages } = extendedWorker;
            if ( promise ) {
                const messageId = `${ id }::${ usages }`;
                const [ message, transfer ] = messagePayload;
                const payload = { id: messageId, data: message };
                return new Promise( ( resolve, reject ) => {
                    ExtendedWorker.resolves[messageId] = resolve;
                    ExtendedWorker.rejects[messageId] = reject;
                    if ( transfer ) {
                        worker.postMessage( payload, transfer );
                    }
                    else {
                        worker.postMessage( payload );
                    }
                } );
            }
            worker.postMessage( ...messagePayload );

        }

        /**
         * ExtendedWorker Message Reception Handling
         * @param {MessageEvent} message - Message received by a Worker
         * @returns {void}
         */
        static onMessage( message ) {
            const { id, err, data } = message.data;
            const resolve = ExtendedWorker.resolves[id];
            const reject = ExtendedWorker.rejects[id];
            if ( !err ) {
                if ( resolve ) {
                    resolve( data );
                }
            }
            else if ( reject ) {
                if ( err ) {
                    reject( err );
                }
            }
            ExtendedWorker.delete( id );
        }

        /**
         * @param {string} id - Unique messageId
         * @returns {void}
         */
        static delete( id ) {
            delete ExtendedWorker.resolves[id];
            delete ExtendedWorker.rejects[id];
        }

        /**
         * @returns {ExtendedWorkerHandler}
         */
        static get Handler() {
            return ExtendedWorkerHandler;
        }

        /**
         * @returns {string}
         */
        static get WrappedHandler() {
            return `()=>(globalThis||self||window).listeners=new (${ ExtendedWorker.Handler.toString() })();`;
        }

        /**
         * Encapsulate a function in a blob to be used as Worker code
         *
         * @param {string} data - Data to be sent to the Worker
         * @returns {string}
         */
        static toObjectURL( data ) {
            return URL.createObjectURL( new Blob( [ data ], { type: 'application/javascript' } ) );
        }

        /**
         * @param {ExtendedWorkerOptions} WorkerOptions
         * @returns {string[]}
         */
        static _parseLocalScriptsImports( WorkerOptions = {} ) {
            const scripts = [];
            if ( 'localImports' in WorkerOptions ) {
                const { localImports: imports } = WorkerOptions;
                if ( typeof imports === 'string' ) {
                    scripts.push( `${ window.location.origin }/${ removeStartingSlash( imports ) }` );
                }
                else if ( Array.isArray( scripts ) ) {
                    scripts.push( ...scripts.map( path => `${ window.location.origin }/${ removeStartingSlash( path ) }` ) );
                }
                else {
                    throw new Error( 'WorkerOptions.localImports is not correctly defined.' );
                }
            }
            return scripts;
        }

        /**
         * @param {ExtendedWorkerOptions} WorkerOptions
         */
        static _parseImportScripts( WorkerOptions = {} ) {
            const scripts = [];
            if ( 'importScripts' in WorkerOptions ) {
                const { importScripts: imports } = WorkerOptions;
                if ( typeof imports === 'string' ) {
                    scripts.push( imports );
                }
                else if ( Array.isArray( imports ) ) {
                    scripts.push( ...imports );
                }
                else {
                    throw new Error( 'WorkerOptions.importScripts is not correctly defined.' );
                }
            }
            return scripts;
        }

        /**
         * @param {ExtendedWorkerOptions} WorkerOptions
         */
        static _parseLocalModuleImports( WorkerOptions = {} ) {
            const modules = [];
            if ( 'localImports' in WorkerOptions ) {
                const { localImports: imports } = WorkerOptions;
                if ( typeof imports === 'string' ) {
                    modules.push( `import ${ getLastPath( imports ) } from '${ window.location.origin }/${ imports }';` );
                }
                else if ( Array.isArray( imports ) ) {
                    for ( const _import of imports ) {
                        if ( typeof _import === 'string' ) {
                            modules.push( `import ${ getLastPath( _import ) } from '${ window.location.origin }/${ removeStartingSlash( _import ) }';` );
                        }
                        else if ( typeof _import === 'object' ) {
                            if ( !( ( 'objects' in _import || '*' in _import || 'name' in _import ) && 'path' in _import ) ) {
                                throw new Error( 'WorkerOptions.importScripts is not correctly defined.' );
                            }
                            const { objects, '*': _as, name, path } = _import;
                            if ( name ) {
                                modules.push( `import ${ name } from '${ window.location.origin }/${ removeStartingSlash( path ) }';` );
                            }
                            else if ( _as ) {
                                modules.push(
                                    `import ${ objects ?
                                    typeof objects === 'string' ?
                                        `{ ${ objects } },` :
                                        `{ ${ objects.join( ',' ) } }, ` :
                                    ''
                                }* as ${ _as } from '${ window.location.origin }/${ removeStartingSlash( path ) }';`
                                );
                            }
                            else if ( objects ) {
                                modules.push(
                                    `import ${ objects ?
                                    typeof objects === 'string' ?
                                        `{ ${ objects } },` :
                                        `{ ${ objects.join( ',' ) } } ` :
                                    ''
                                } from '${ window.location.origin }/${ removeStartingSlash( path ) }';`
                                );
                            }
                            else {
                                throw new Error( 'WorkerOptions.importScripts is not correctly defined.' );
                            }
                        }
                    }
                }
                else {
                    throw new Error( 'WorkerOptions.localImports is not correctly defined.' );
                }
            }
            if ( 'includeHandler' in WorkerOptions && WorkerOptions.includeHandler === true ) {
                modules.push( `import multithread from '${ window.location.origin }/src/multithread.js';` );
            }
            return modules;
        }

        /**
         * @param {ExtendedWorkerOptions} WorkerOptions
         */
        static _parseImportModuleScripts( WorkerOptions = {} ) {
            const modules = [];
            if ( 'importScripts' in WorkerOptions ) {
                const { importScripts: imports } = WorkerOptions;
                if ( typeof imports === 'string' ) {
                    modules.push( `import ${ getLastPath( imports ) } from '${ imports }';` );
                }
                else if ( Array.isArray( imports ) ) {
                    for ( const _import of imports ) {
                        if ( typeof _import === 'string' ) {
                            modules.push( `import ${ getLastPath( _import ) } from '${ _import }';` );
                        }
                        else if ( typeof _import === 'object' ) {
                            if ( !( ( 'objects' in _import || '*' in _import || 'name' in _import ) && 'path' in _import ) ) {
                                throw new Error( 'WorkerOptions.importScripts is not correctly defined.' );
                            }
                            const { objects, '*': _as, name, path } = _import;
                            if ( name ) {
                                modules.push( `import ${ name } from '${ path }';` );
                            }
                            else if ( _as ) {
                                modules.push(
                                    `import ${ objects ?
                                    typeof objects === 'string' ?
                                        `{ ${ objects } },` :
                                        `{ ${ objects.join( ',' ) } }, ` :
                                    ''
                                }* as ${ _as } from '${ path }';`
                                );
                            }
                            else if ( objects ) {
                                modules.push(
                                    `import ${ objects ?
                                    typeof objects === 'string' ?
                                        `{ ${ objects } },` :
                                        `{ ${ objects.join( ',' ) } } ` :
                                    ''
                                } from '${ path }';`
                                );
                            }
                            else {
                                throw new Error( 'WorkerOptions.importScripts is not correctly defined.' );
                            }
                        }
                    }
                }
                else {
                    throw new Error( 'WorkerOptions.importScripts is not correctly defined.' );
                }
            }
            return modules;
        }

        static _exportHandlerToScriptImport() {
            return ExtendedWorker.toObjectURL( `(${ ExtendedWorker.WrappedHandler })();` );
        }

        /**
         * @param {string} WorkerString
         */
        static _uglifyWorkerToScript( WorkerString ) {
            if ( typeof WorkerString === 'string' ) {
                return ExtendedWorker.toObjectURL( WorkerString );
            }
            throw new Error( 'WorkerString is not a string.' );
        }

        /**
         * @param {string} WorkerString
         * @param {ExtendedWorkerOptions} WorkerOptions
         * @returns {string}
         */
        static _craftScriptForModuleImport( WorkerString, WorkerOptions = {} ) {
            if ( typeof WorkerString !== 'string' ) {
                throw new Error( 'WorkerString is not a string.' );
            }
            const modules = [
                ...ExtendedWorker._parseLocalModuleImports( WorkerOptions ),
                ...ExtendedWorker._parseImportModuleScripts( WorkerOptions )
            ];
            let WorkerBody;
            if ( 'uglify' in WorkerOptions && WorkerOptions.uglify === true ) {
                throw new Error( 'WorkerOptions.uglify can not be applied to module worker.' );
            }
            else {
                WorkerBody = `${ modules.length > 0 ? `${ modules.join( '\n' ) }\n` : '' }(${ WorkerString })();`;
            }
            return ExtendedWorker.toObjectURL( WorkerBody );
        }

        /**
         * @param {string} WorkerString
         * @param {ExtendedWorkerOptions} WorkerOptions
         * @returns {string}
         */
        static _craftScriptForScriptImport( WorkerString, WorkerOptions = {} ) {
            if ( typeof WorkerString !== 'string' ) {
                throw new Error( 'WorkerString is not a string.' );
            }
            const scripts = [
                ...ExtendedWorker._parseLocalScriptsImports( WorkerOptions ),
                ...ExtendedWorker._parseImportScripts( WorkerOptions )
            ];
            if ( 'includeHandler' in WorkerOptions && WorkerOptions.includeHandler === true ) {
                scripts.push( ExtendedWorker._exportHandlerToScriptImport() );
            }
            let WorkerBody;
            if ( 'uglify' in WorkerOptions && WorkerOptions.uglify === true ) {
                scripts.push( ExtendedWorker._uglifyWorkerToScript( WorkerString ) );
                WorkerBody = `importScripts("${ scripts.join( '","' ) }");`;
            }
            else {
                WorkerBody = `${ scripts.length > 0 ? `importScripts("${ scripts.join( '","' ) }");\n` : '' }(${ WorkerString })();`;
            }
            return ExtendedWorker.toObjectURL( WorkerBody );

        }

        /**
         * @param {string} WorkerString
         * @param {ExtendedWorkerOptions} WorkerOptions
         * @returns {string}
         */
        static createObjectURL( WorkerString = '', WorkerOptions = {} ) {
            if ( typeof WorkerOptions === 'object' ) {
                if ( 'type' in WorkerOptions && WorkerOptions.type === 'module' ) {
                    return ExtendedWorker._craftScriptForModuleImport( WorkerString, WorkerOptions );
                }
                else if ( 'type' in WorkerOptions && !( WorkerOptions.type === 'module' || WorkerOptions.type === 'classic' ) ) {
                    throw new Error( `WorkerOptions.type:${ WorkerOptions.type } is not a valid type.` );
                }
                else {
                    return ExtendedWorker._craftScriptForScriptImport( WorkerString, WorkerOptions );
                }
            }
            else if ( typeof WorkerString === 'string' ) {
                return ExtendedWorker.toObjectURL( WorkerString );
            }
            throw new Error( 'WorkerString is not a string.' );
        }

        /**
         * Return a proxied ExtendedWorker
         *
         * The proxied ExtendedWorker is by default a module worker set to receive promise-based messages and managed through an builtin handler
         *
         * @param {string|Function} WorkerObject
         * @param {ExtendedWorkerOptions} WorkerOptions
         * @returns {ExtendedWorkerProxy}
         */
        static new( WorkerObject, WorkerOptions = {} ) {
            return new ExtendedWorker( WorkerObject, { promise: true, type: 'module', includeHandler: true, ...WorkerOptions } ).proxy;
        }

        /**
         * Run a single function in a worker and terminate the worker once the function has been executed
         *
         * @param {string|Function} func
         * @param {...any} args
         */
        static async run( func, data, transferable ) {
            const worker = ExtendedWorker.new( `async()=>_.run(${ func })` );
            const result = await worker.run( data, transferable );
            worker.terminate();
            return result;
        }

        /**
         * @param {string|Function} WorkerObject
         * @param {ExtendedWorkerOptions} WorkerOptions
         */
        constructor( WorkerObject, WorkerOptions ) {
            let _workerObject;
            if ( typeof WorkerObject === 'function' ) {
                _workerObject = ExtendedWorker.createObjectURL( WorkerObject.toString(), WorkerOptions );
            }
            else if ( typeof WorkerObject === 'string' ) {
                _workerObject = ExtendedWorker.createObjectURL( WorkerObject, WorkerOptions );
            }
            else {
                throw new Error( 'WorkerObject is not a string or a function.' );
            }
            Object.defineProperty( this, 'worker', { value: new Worker( _workerObject, WorkerOptions ) } );
            Object.defineProperty( this, 'promise', { value: WorkerOptions && WorkerOptions.promise } );
            this._usages = 0;
            if ( WorkerOptions && 'promise' in WorkerOptions && WorkerOptions.promise === true ) {
                Object.defineProperty( this, 'id', { value: ExtendedWorker.id } );
                this.worker.onmessage = ExtendedWorker.onMessage;
            }
        }

        /**
         * @returns {number}
         */
        get usages() {
            return this._usages++;
        }

        /**
         * @returns {ExtendedWorkerProxy}
         */
        get proxy() {
            return new Proxy( this, {
                get: ( target, property ) => {
                    if ( property in target ) {
                        return target[property];
                    }
                    return ( data, transferable ) => target.postMessage( { type: property, data }, transferable );
                }
            } );
        }

        set onmessage( func ) {
            this.worker.onmessage = func;
        }

        get onmessage() {
            return this.worker.onmessage;
        }

        set onerror( func ) {
            this.worker.onerror = func;
        }

        get onerror() {
            return this.worker.onerror;
        }

        set onmessageerror( func ) {
            this.worker.onmessageerror = func;
        }

        get onmessageerror() {
            return this.worker.onmessageerror;
        }

        /**
         * @param {Event} event
         * @returns {Boolean}
         */
        dispatchEvent( event ) {
            return this.worker.dispatchEvent( event );
        }

        /**
         * Add event listener in target's event listener list
         * @param {any} type
         * @param {(ev:any).any} listener
         * @param {boolean|AddEventListenerOptions} [options]
         */
        addEventListener( type, listener, options ) {
            return this.worker.addEventListener( type, listener, options );
        }

        /**
         * Removes the event listener in target's event listener list with the same type, callback, and options.
         * @param {any} type
         * @param {(ev:any).any} listener
         * @param {boolean|EventListenerOptions} [options]
         */
        removeEventListener( type, listener, options ) {
            this.worker.removeEventListener( type, listener, options );
        }

        terminate() {
            this.worker.terminate();
        }

        /**
         * Post message to Worker
         * @param {any} message - Message to pass to Worker
         * @param {Transferable[]} [transfer] - Transferable Object List to pass to Worker
         * @returns {void|Promise}
         */
        postMessage( message, transfer ) {
            return ExtendedWorker.postMessage( [ message, transfer ], this );
        }

    }

    class Cluster {

        /**
         * @typedef {Object} ClusterOptions
         * @property {number} [size=4] - Number of Workers to spawn
         */

        /**
         * @typedef {Object} ClusterExecutionMode
         * @property {boolean} race
         * @property {boolean} spread
         */

        /**
         * @typedef {Object} ClusterMessageOptions
         * @property {ClusterExecutionMode} [mode]
         * @property {any} data
         * @property {Transferable[]} transferable
         */

        /**
         * @typedef {Cluster & Proxy} ClusterProxy
         */

        static {
            this.DEFAULT_SIZE = 4;
        }

        /**
         * Return a proxied Cluster
         *
         * The proxied Cluster is by default a group of 4 module workers set to receive promise-based messages and managed through the builtin handler
         *
         * @param {string|Function} WorkerObject
         * @param {ExtendedWorkerOptions & ClusterOptions} ClusterOptions
         * @returns {ClusterProxy}
         */
        static new( WorkerObject, ClusterOptions = { size: Cluster.DEFAULT_SIZE } ) {
            return new Cluster( WorkerObject, { promise: true, type: 'module', includeHandler: true, ...ClusterOptions } ).proxy;
        }

        /**
         * @param {Function} func
         * @param {any} data
         * @param {Transferable[]} transferable
         */
        static async run( func, data, transferable ) {
            const cluster = Cluster.new( `async()=>_.run(${ func })`, { size: Cluster.DEFAULT_SIZE } );
            const result = await cluster.run( data, transferable );
            cluster.terminate();
            return result;
        }

        /**
         * @param {Function} func
         * @param {any} data
         * @param {Transferable[]} transferable
         */
        static async $run( func, data, transferable ) {
            const cluster = Cluster.new( `async()=>_.run(${ func })`, { size: Cluster.DEFAULT_SIZE } );
            const result = await cluster.$run( data, transferable );
            cluster.terminate();
            return result;
        }

        static async _run( func, data, transferable ) {
            const cluster = Cluster.new( `async()=>_.run(${ func })`, { size: Cluster.DEFAULT_SIZE } );
            const result = await cluster._run( data, transferable );
            cluster.terminate();
            return result;
        }

        /**
         * @param {Function} func
         * @param {any} data
         * @param {Transferable[]} transferable
         */
        // eslint-disable-next-line camelcase
        static async $_run( func, data, transferable ) {
            const cluster = Cluster.new( `async()=>_.run(${ func })`, { size: Cluster.DEFAULT_SIZE } );
            const result = await cluster.$_run( data, transferable );
            cluster.terminate();
            return result;
        }

        /**
         * @param {string|number|Symbol} property
         */
        static parsePropertyDecorator( property ) {
            if ( typeof property === 'string' ) {
                const { groups } = property.match( /^(?<race>\$)?(?<spread>_)?/u );
                const race = Boolean( groups.race );
                const spread = Boolean( groups.spread );
                return {
                    modes: { race, spread },
                    property: property.slice( race + spread )
                };
            }
            return property;
        }

        /**
         * Cluster of ExtendedWorker
         *
         * @param {string|Function} WorkerObject
         * @param {ExtendedWorkerOptions & ClusterOptions} ClusterOptions
         */
        constructor( WorkerObject, ClusterOptions ) {
            this.workers = [];
            this.size = Cluster.DEFAULT_SIZE;
            if ( typeof ClusterOptions === 'object' && 'size' in ClusterOptions ) {
                this.size = +ClusterOptions.size;
            }
            for ( let i = 0; i < this.size; i++ ) {
                this.workers.push( new ExtendedWorker( WorkerObject, ClusterOptions ) );
            }
        }

        /**
         * @returns {ClusterProxy}
         */
        get proxy() {
            return new Proxy( this, {
                get: ( target, property ) => {
                    if ( property in target ) {
                        return target[property];
                    }
                    const { modes, property: propertyName } = Cluster.parsePropertyDecorator( property );
                    return ( data, transferable ) => target.postMessage( { type: propertyName }, undefined, { modes, data, transferable } );
                }
            } );
        }

        /**
         * @param {Event} event
         * @returns {Boolean[]}
         */
        dispatchEvent( event ) {
            return this.workers.map( worker => worker.dispatchEvent( event ) );
        }

        /**
         * Add event listener in target's event listener list
         * @param {any} type
         * @param {(ev:any).any} listener
         * @param {boolean|AddEventListenerOptions} [options]
         */
        addEventListener( type, listener, options ) {
            return this.workers.map( worker => worker.addEventListener( type, listener, options ) );
        }

        /**
         * Removes the event listener in target's event listener list with the same type, callback, and options.
         * @param {any} type
         * @param {(ev:any).any} listener
         * @param {boolean|EventListenerOptions} [options]
         */
        removeEventListener( type, listener, options ) {
            return this.workers.map( worker => worker.removeEventListener( type, listener, options ) );
        }

        /**
         * Post message to Workers
         * @param {any} message - Message to pass to Workers
         * @param {Transferable[]} [transfer] - Transferable Object List to pass to Worker
         * @param {Transferable[]} [transfer] - Transferable Object List to pass to Worker
         * @returns {Promise}
         */
        postMessage( message, transfer, { modes: { race, spread } = {}, data, transferable } = {} ) {
            if ( race !== undefined || spread !== undefined ) {
                switch ( true ) {
                    case race && spread:
                        return Promise.race( this.workers.map( ( worker, i ) => worker.postMessage( { ...message, data: data[i] }, transferable ? transferable[i] : null ) ) );
                    case race:
                        return Promise.race( this.workers.map( worker => worker.postMessage( { ...message, data }, transferable ) ) );
                    case spread:
                        return Promise.all( this.workers.map( ( worker, i ) => worker.postMessage( { ...message, data: data[i] }, transferable ? transferable[i] : null ) ) );
                    default:
                        return Promise.all( this.workers.map( worker => worker.postMessage( { ...message, data }, transferable ) ) );
                }
            }
            return Promise.all( this.workers.map( worker => worker.postMessage( message, transfer ) ) );
        }

        terminate() {
            this.workers.forEach( worker => worker.terminate() );
        }

    }

    const Handler = isWorker() ? new ExtendedWorkerHandler() : undefined;

    var multithread = {
        ExtendedWorker,
        ExtendedWorkerHandler,
        Cluster,
        Handler
    };

    /* eslint-env module */

    class MarkdownParser {

        /**
         * @param {String} MarkdownParserLibraryURL
         */
        constructor( MarkdownParserLibraryURL ) {
            this.worker = new ExtendedWorker(
                () => {
                    globalThis.onmessage = function onmessage( event ) {
                        globalThis.postMessage( { id: event.data.id, data: { data: marked.marked( event.data.data ) } } );
                    };
                },
                { promise: true, importScripts: MarkdownParserLibraryURL || 'https://cdn.jsdelivr.net/npm/marked/marked.min.js' }
            );
        }

        /**
         * @param {String} text
         * @returns {Promise<String>} HTML Formatted Content
         */
        async parse( text ) {
            return ( await this.worker.postMessage( text ) ).data;
        }

        /**
         * @returns {void}
         */
        terminate() {
            this.worker.terminate();
        }

    }

    class VariableManager {

        constructor() {
            const gl = getGlobal$1();
            if ( !( 'VariableManager' in gl ) ) {
                gl.VariableManager = this;
                this.map = {};
            }
            else if ( gl.VariableManager !== this ) {
                throw new Error( 'You are allowed to instantiate only one VariableManager per page' );
            }
        }

        /**
         * @typedef {Object} VariableHandler
         * @property {Function} exec
         * @property {Object} parser
         *
         */

        /**
         * @param {String} key - Key to look for to be replaced by object
         * @param {VariableHandler} object - Function and parser to call on item found thanks to key
         * @returns {void}
         */
        register( key, object ) {
            const _object = typeof object === 'object' ? object : {};
            const { exec, parser } = _object;
            if ( key in this.map || !( exec || parser ) ) {
                throw new Error( 'Key already registered or invalid object' );
            }
            this.map[key] = { exec, parser };
        }

        execute() {
            const { body } = document;
            const nodes = [ body ];
            const found = [];
            while ( nodes.length > 0 ) {
                const currentNode = nodes.shift();
                const { length: l } = currentNode.childNodes;
                for ( let i = 0; i < l; i += 1 ) {
                    const currentChild = currentNode.childNodes[i];
                    if ( [ 1, 11 ].includes( currentChild.nodeType ) ) {
                        nodes.unshift( currentChild );
                    }
                    else if ( [ 3, 8 ].includes( currentChild.nodeType ) ) {
                        if ( ( /\{\{(?:.|\n|\r)*\}\}/gu ).test( currentChild.textContent ) ) {
                            found.push( currentChild.parentNode );
                        }
                    }
                }
                const { length: l2 } = currentNode.attributes;
                for ( let i = 0; i < l2; i += 1 ) {
                    const currentAttribute = currentNode.attributes[i];
                    if ( ( /\{\{(?:.|\n|\r)*\}\}/gu ).test( currentAttribute.value ) ) {
                        found.push( currentAttribute );
                    }
                }
            }

            for ( const fo of found ) {
                if ( fo.nodeType === 2 ) {
                    const attr = fo.nodeValue;
                    objectForEach( this.map, async ( key, value ) => {
                        const reg = new RegExp( `\\{\\{${ key }:?(?:.|\\n|\\r)*?\\}\\}`, 'gu' );
                        const res = reg.exec( attr );
                        if ( res && res.length === 1 ) {
                            const [ fres ] = res.filter( e => e );
                            const { parser, exec } = value;
                            const e = exec( VariableManager.parse( key, parser, fres ) );
                            if ( e instanceof Promise ) {
                                fo.nodeValue = await e;
                            }
                            else {
                                fo.nodeValue = e;
                            }
                        }
                    } );
                }
                else {
                    objectForEach( this.map, async ( key, value ) => {
                        let html = fo.innerHTML;
                        fo.innerHTML = '';
                        const reg = new RegExp( `\\{\\{${ key }:?(?:.|\\n|\\r)*?\\}\\}`, 'gu' );
                        const res = html.match( reg );
                        if ( res && res.length > 0 ) {
                            const { parser, exec } = value;
                            for ( const re of res ) {
                                let rex = html.indexOf( re );
                                while ( (rex = html.indexOf( re )) > -1 ) {
                                    const leftHTML = html.substring( 0, rex );
                                    const rightHTML = html.substring( rex + re.length );
                                    const e = exec( VariableManager.parse( key, parser, re ) );
                                    if ( e instanceof Promise ) {
                                        const ee = await e;
                                        if ( ee instanceof Element ) {
                                            html = leftHTML + ee.outerHTML + rightHTML;
                                        }
                                        else if ( ee instanceof Node ) {
                                            html = leftHTML + ee.textContent + rightHTML;
                                        }
                                        else {
                                            html = leftHTML + ee + rightHTML;
                                        }
                                    }
                                    else {
                                        if ( e instanceof Element ) {
                                            html = leftHTML + e.outerHTML + rightHTML;
                                        }
                                        else if ( e instanceof Node ) {
                                            html = leftHTML + e.textContent + rightHTML;
                                        }
                                        else {
                                            html = leftHTML + e + rightHTML;
                                        }
                                    }
                                }
                            }
                        }
                        fo.innerHTML = html;
                    } );
                }
            }
        }

        async asyncExecute() {
            this.execute();
        }

        /**
         * @param {String} key
         * @param {Object} parser
         * @param {String} result
         */
        static parse( key, parser, result ) {
            if ( result.length < 4 + key.length + 1 + 3 ) {
                return {};
            }
            const trimmed = result.slice( 2 + key.length + 1, result.length - 2 );
            const cut = trimmed.split( /;/gu );
            return cut.reduce( ( prev, curr ) => {
                const [ prop, value ] = curr.split( /[=]/u );
                if ( prop in parser ) {
                    if ( parser[prop] === 'number' ) {
                        try {
                            prev[prop] = Number( value );
                        }
                        catch ( _ ) {
                            console.error( _ );
                        }
                    }
                    else if ( parser[prop] === 'symbol' ) {
                        try {
                            prev[prop] = Symbol( value );
                        }
                        catch ( _ ) {
                            console.error( _ );
                        }
                    }
                    else if ( parser[prop] === 'string' ) {
                        prev[prop] = value.toString();
                    }
                    else if ( parser[prop] === 'boolean' ) {
                        try {
                            prev[prop] = Boolean( value );
                        }
                        catch ( _ ) {
                            console.error( _ );
                        }
                    }
                }
                else {
                    prev[prop] = value;
                }
                return prev;
            }, {} );
        }

        static execute() {
            const gl = getGlobal$1();
            if ( !( 'VariableManager' in gl ) ) {
                throw new Error( 'VariableManager was not instantiated.' );
            }
            return gl.VariableManager.execute();
        }

        static asyncExecute() {
            const gl = getGlobal$1();
            if ( !( 'VariableManager' in gl ) ) {
                throw new Error( 'VariableManager was not instantiated.' );
            }
            return gl.VariableManager.asyncExecute();
        }

    }

    var content = { MarkdownParser, VariableManager };

    /* eslint-env module */

    /**
     * Check whether a class is present in an element's classlist
     * @param {HTMLElement} element - Element on which to check if the class is present
     * @param {String} className - Class to check
     * @returns {Boolean} Whether an element has checked class or not
     */
    function hasClass( element, className ) {
        if ( element && element instanceof Element && !!className && typeof className === 'string' ) {
            return element.classList.contains( className );
        }
        throw new Error( 'Element and/or ClassName arguments are not correct.' );
    }

    /**
     * Add a class to an element's classList
     * @param {HTMLElement} element - Element on which to add the class
     * @param {String} className - Class to add
     * @param {Boolean} [requireAnimationFrame] - Require an animation frame to add the class
     * @returns {DOMTokenList|Promise<DOMTokenList>} Classlist containing the added class
     */
    function addClass( element, className, requireAnimationFrame ) {
        const _requireAnimationFrame = requireAnimationFrame || false;
        if ( element && element instanceof Element && !!className && typeof className === 'string' ) {
            if ( _requireAnimationFrame ) {
                return new Promise( resolve => {
                    window.requestAnimationFrame( () => {
                        element.classList.add( className );
                        resolve( element.classList );
                    } );
                } );
            }
            element.classList.add( className );
            return element.classList;

        }
        throw new Error( 'Element and/or ClassName arguments are not correct.' );
    }
    /**
     * Remove a class from an element's classlist
     * @param {HTMLElement} element - Element from which to remove the class
     * @param {String} className - Class to add
     * @param {Boolean} [requireAnimationFrame] - Require an animation frame to remove the class
     * @returns {DOMTokenList|Promise<DOMTokenList>} Classlist without the removed class
     */
    function removeClass( element, className, requireAnimationFrame ) {
        const _requireAnimationFrame = requireAnimationFrame || false;
        if ( element && element instanceof Element && !!className && typeof className === 'string' ) {
            if ( _requireAnimationFrame ) {
                return new Promise( resolve => {
                    window.requestAnimationFrame( () => {
                        element.classList.remove( className );
                        resolve( element.classList );
                    } );
                } );
            }
            element.classList.remove( className );
            return element.classList;

        }
        throw new Error( 'Element and/or ClassName arguments are not correct.' );
    }
    /**
     * Toggle classname from element and request a frame before toggling it
     * @param {HTMLElement} element - Element on which to toggle the class
     * @param {String} className - Class to toggle
     * @param {Boolean} [requireAnimationFrame] - Require an animation frame to toggle the class
     * @returns {DOMTokenList|Promise<DOMTokenList>} Classlist containing or not the targeted class
     */
    function toggleClass( element, className, requireAnimationFrame ) {
        const _requireAnimationFrame = requireAnimationFrame || false;
        if ( element && element instanceof Element && !!className && typeof className === 'string' ) {
            return hasClass( element, className ) ?
                removeClass( element, className, _requireAnimationFrame ) :
                addClass( element, className, _requireAnimationFrame );
        }
        throw new Error( 'Element and/or ClassName arguments are not correct.' );
    }
    /**
     * Get or set attribute of Element or return all the attributes
     * @param {HTMLElement} element
     * @param {String} [attrName]
     * @param {Any} [value]
     * @returns {NamedNodeMap|String|void}
     */
    function attr( element, attrName, value ) {
        if ( !!attrName && typeof attrName === 'string' ) {
            if ( value !== undefined ) {
                return element.setAttribute( attrName, value );
            }
            return element.getAttribute( attrName );
        }
        return element.attributes;
    }
    /**
     * Get or set data attributes of Element or return all dataset
     * @param {HTMLElement} element
     * @param {String} [dataset]
     * @param {Any} [value]
     * @returns {DOMStringMap|String|void}
     */
    function data( element, dataset, value ) {
        if ( !!dataset && typeof dataset === 'string' ) {
            if ( value !== undefined ) {
                element.dataset[dataset] = value;
                return element.dataset[dataset];
            }
            return element.dataset[dataset];
        }
        return element.dataset;
    }

    /**
     * @typedef {[string,(this:HTMLElement,ev:any)=>void,AddEventListenerOptions]} EventListenerArguments
     * @type {Array}
     */

    /**
     * @typedef {Object} ElementCreationShorthandInput
     * @property {Object} attr
     * @property {String} attr.*
     * @property {String|String[]} class
     * @property {Object} data
     * @property {String} data.*
     * @property {EventListenerArguments[]} events
     * @property {String} id
     * @property {String} ns
     * @property {Object} style
     * @property {String} style.*
     * @property {String} t
     * @property {any|any[]} _
     */

    /**
     * Element Creation Shorthand
     *
     * @param {Array.<ElementCreationShorthandInput|ElementCreationShorthandInput[]|Element|Element[]>} [args]
     * @returns {HTMLElement}
     */
    function ecs( ...args ) {
        const { length } = args;
        const _args = args.filter( item => !!item );
        if ( length === 0 ) {
            return document.createElement( 'div' );
        }
        if ( length !== 1 ) {
            const wrapper = document.createElement( 'div' );
            for ( let i = 0; i < length; i += 1 ) {
                wrapper.appendChild( ecs( _args[i] ) );
            }
            return wrapper;
        }
        let current = _args[0];
        if ( current instanceof Element ) {
            return current;
        }
        const {
            actions: $actions,
            attr: $attr,
            class: $class,
            data: $dataset,
            _: $childElements,
            events: $events,
            id,
            ns: $namespace,
            style: $style,
            t: $tag
        } = current;
        if ( id || $class || $tag ) {
            if ( !!$namespace && typeof $namespace === 'string' ) {
                current = document.createElementNS( $namespace, !!$tag && typeof $tag === 'string' ? $tag : 'div' );
            }
            else {
                current = document.createElement( !!$tag && typeof $tag === 'string' ? $tag : 'div' );
            }
            if ( id ) {
                current.id = id;
            }
            if ( $class ) {
                if ( typeof $class === 'string' ) {
                    current.classList.add( $class );
                }
                else if ( Array.isArray( $class ) ) {
                    current.classList.add( ...$class );
                }
            }
        }
        else {
            current = document.createElement( 'div' );
        }
        if ( $attr ) {
            objectForEach( $attr, ( key, value ) => {
                if ( value instanceof Promise ) {
                    value.then(
                        response => {
                            attr( current, key, response );
                        },
                        error => {
                            console.error( error );
                        }
                    );
                }
                else {
                    attr( current, key, value );
                }
            } );
        }
        if ( $dataset ) {
            objectForEach( $dataset, ( key, value ) => {
                if ( value instanceof Promise ) {
                    value.then(
                        response => {
                            current.dataset[key] = response;
                        },
                        error => {
                            console.error( error );
                        }
                    );
                }
                else {
                    current.dataset[key] = value;
                }
            } );
        }
        if ( $events ) {
            for ( const event of $events ) {
                current.addEventListener( ...event );
            }
        }
        if ( $style ) {
            objectForEach( $style, ( key, value ) => {
                if ( value instanceof Promise ) {
                    value.then(
                        response => {
                            current.style[key] = response;
                        },
                        error => {
                            console.error( error );
                        }
                    );
                }
                current.style[key] = value;
            } );
        }
        if ( $childElements ) {
            for ( const item of typeof $childElements === 'object' && Symbol.iterator in $childElements ? $childElements : [ $childElements ] ) {
                if ( item instanceof Element ) {
                    current.appendChild( item );
                }
                else if ( typeof item === 'string' ) {
                    current.innerHTML += item;
                }
                else if ( item instanceof Promise ) {
                    const template = document.createElement( 'template' );
                    current.appendChild( template );
                    item.then(
                        response => {
                            if ( typeof response === 'string' ) {
                                template.outerHTML += response;
                                template.remove();
                            }
                            else {
                                current.replaceChild( ecs( response ), template );
                            }
                        },
                        _ => {
                            console.error( 'ecs error: ', _ );
                        }
                    );
                }
                else if ( [ 'number', 'bigint', 'boolean', 'symbol' ].includes( typeof item ) ) {
                    current.innerHTML += `${ item }`;
                }
                else {
                    current.appendChild( ecs( item ) );
                }
            }
        }
        if ( $actions ) {
            objectForEach( $actions, ( key, values ) => {
                const filteredKey = key.split( /_\$/u );
                if ( filteredKey.length > 1 ) {
                    current[filteredKey[0]]( ...values );
                }
                else {
                    current[key]( ...values );
                }
            } );
        }
        return current;
    }
    /**
     * Execute ecs in an inline script an replace script by ecs' result
     * @param {Array.<ElementCreationShorthandInput|ElementCreationShorthandInput[]|Element|Element[]>} args
     */
    function ecsr( ...args ) {
        const { currentScript } = document;
        const { parentElement } = currentScript;
        if ( ![ document.head, document.documentElement ].includes( parentElement ) ) {
            parentElement.replaceChild( ecs( ...args ), currentScript );
        }
    }

    var dom = {
        hasClass,
        addClass,
        removeClass,
        toggleClass,
        attr,
        data,
        ecs,
        ecsr
    };

    /* eslint-env module */

    class DatasetEncoder {

        /**
         * @param {String} key
         * @returns {DatasetEncoder}
         */
        constructor() {
            this.values = [];
        }

        /**
         * @param {any} value
         * @returns {Number}
         */
        getEncoded( value ) {
            const index = this.values.indexOf( value );
            if ( index > -1 ) {
                return index;
            }
            this.length = this.values.push( value );
            return this.length - 1;

        }

        /**
         * @param {Number} encodedIndex
         * @returns {any}
         */
        getDecoded( encodedIndex ) {
            if ( this.length <= encodedIndex ) {
                throw new Error();
            }
            else {
                return this.values[encodedIndex];
            }
        }

        /**
         * @param {any} value
         * @returns {Array<Number>}
         */
        getOneHotEncoded( value ) {
            const index = this.values.indexOf( value );
            if ( index > -1 ) {
                const array = Array( this.values.length ).fill( 0 );
                array[index] = 1;
                return array;
            }
            throw new Error();
        }

        /**
         * @param {Number} index
         * @returns {Array<0|1>}
         */
        getOneHotEncodedByIndex( index ) {
            const { length } = this.values;
            if ( index >= length || index < 0 ) {
                throw new Error();
            }
            else {
                const array = Array( length ).fill( 0 );
                array[index] = 1;
                return array;
            }
        }

    }

    class DatasetHeader {

        /**
         * @typedef {Object} DatasetHeaderOptions
         * @property {Object} [types]
         * @property {String|Function} types.*
         * @property {String|String[]} [encoders]
         *
         * @typedef {Object} DatasetHeaderColumnInfo
         * @property {String} key
         * @property {Number} index
         * @property {Function} [type]
         * @property {DatasetEncoder} [encoder]
         */

        /**
         * @param {String[]} array
         * @param {DatasetHeaderOptions} [options]
         */
        constructor( array, options ) {
            /** @type {Map<Number,String>} */
            this.keys = new Map();
            /** @type {Map<String,Function>} */
            this.types = new Map();
            /** @type {Map<String,Number>} */
            this.indexes = new Map();
            /** @type {Map<String,DatasetEncoder>} */
            this.encoders = new Map();

            this.nextIndex = 0;

            if ( array ) {
                this.parseFromArray( array, options );
            }
        }

        /**
         * @returns {String[]}
         */
        get columns() {
            return [ ...this.indexes.keys() ];
        }

        /**
         * @param {String} key
         * @returns {DatasetHeaderColumnInfo}
         */
        getColumnByKey( key ) {
            if ( this.indexes.has( key ) ) {
                return {
                    key,
                    index: this.indexes.get( key ),
                    ...this.types.has( key ) ? { type: this.types.get( key ) } : {},
                    ...this.encoders.has( key ) ? { encoder: this.encoders.get( key ) } : {}
                };
            }

            return undefined;

        }

        /**
         * @param {Number} index
         * @returns {DatasetHeaderColumnInfo}
         */
        getColumnByIndex( index ) {
            if ( this.keys.has( index ) ) {
                const key = this.keys.get( index );
                return {
                    key,
                    index,
                    ...this.types.has( key ) ? { type: this.types.get( key ) } : {},
                    ...this.encoders.has( key ) ? { encoder: this.encoders.get( key ) } : {}
                };
            }
            return undefined;

        }

        /**
         * @param {Number} index
         * @returns {String}
         */
        getColumnKeyByColumnIndex( index ) {
            return this.keys.get( index );
        }

        /**
         * @param {String} key
         * @returns {Number}
         */
        getColumnIndexByColumnKey( key ) {
            return this.indexes.get( key );
        }

        /**
         * @param {String} key
         * @return {DatasetEncoder}
         */
        registerColumnEncoderByColumnKey( key ) {
            const encoder = new DatasetEncoder( key );
            this.encoders.set( key, encoder );
            return encoder;
        }

        /**
         * @param {String} key
         * @returns {DatasetEncoder}
         */
        getColumnEncoderByColumnKey( key ) {
            return this.encoders.get( key );
        }

        /**
         * @param {Number} index
         * @returns {DatasetEncoder}
         */
        registerColumnEncoderByColumnIndex( index ) {
            const key = this.keys.get( index );
            const encoder = new DatasetEncoder( key );
            this.encoders.set( key, encoder );
            return encoder;
        }

        /**
         * @param {Number} index
         * @returns {DatasetEncoder}
         */
        getColumnEncoderByColumnIndex( index ) {
            return this.encoders.get( this.keys.get( index ) );
        }

        /**
         * @param {String} key
         * @returns {Function}
         */
        getColumnTypeByColumnKey( key ) {
            return this.types.get( key );
        }

        /**
         * @param {String} key
         * @param {String|Function} type
         */
        setColumnTypeByColumnKey( key, type ) {
            this.types.set( key, Dataset.parseType( type ) );
        }

        /**
         * @param {Number} index
         * @returns {Function}
         */
        getColumnTypeByColumnIndex( index ) {
            return this.types.get( this.keys.get( index ) );
        }

        /**
         * @param {Number} index
         * @param {String|Function} type
         */
        setColumnTypeByColumnIndex( index, type ) {
            this.types.set( this.keys.get( index ), Dataset.parseType( type ) );
        }

        /**
         * @param {String} key
         * @returns {Boolean}
         */
        hasColumn( key ) {
            return this.indexes.has( key );
        }

        /**
         * @param {Number} index
         * @returns {Boolean}
         */
        doesIndexExist( index ) {
            return this.keys.has( index );
        }

        /**
         * @param {String} key
         * @param {String|Function} type
         * @param {Boolean} [toBeEncoded]
         */
        addColumn( key, type, toBeEncoded = false ) {
            const index = this.nextIndex++;
            this.keys.set( index, key );
            this.indexes.set( key, index );
            this.types.set( key, Dataset.parseType( type ) );
            if ( toBeEncoded ) {
                this.encoders.set( key, new DatasetEncoder( key ) );
            }
        }

        /**
         * @param {String[]} keys
         * @returns {Number[]}
         */
        removeColumns( keys ) {
            const _keys = Array.isArray( keys ) ? keys : [ keys ];
            const oldIndexes = [];
            for ( const key of _keys ) {
                this.types.delete( key );
                this.encoders.delete( key );
                const oldIndex = this.indexes.get( key );
                this.keys.delete( oldIndex );
                this.indexes.delete( key );
                oldIndexes.push( oldIndex );
            }
            /** @type {Map<String,Number>} */
            const newIndexes = new Map();
            /** @type {Map<Number,String>} */
            const newKeys = new Map();
            let newIndex = 0;
            for ( const currentKey of this.indexes.keys() ) {
                newIndexes.set( currentKey, newIndex );
                newKeys.set( newIndex, currentKey );
                newIndex += 1;
            }
            this.indexes = newIndexes;
            this.keys = newKeys;
            this.nextIndex = newIndex;
            return oldIndexes;
        }

        /**
         * @param {String[]} array
         * @param {DatasetHeaderOptions} [options]
         * @returns {DatasetHeader}
         */
        parseFromArray( array, options = {} ) {
            const { types = {}, encoders = [] } = options;
            for ( const key of array ) {
                this.addColumn( key, types[key], encoders.includes( key ) );
            }
            this.nextIndex = array.length;
        }

        /**
         * @param {String[]} array
         * @param {DatasetHeaderOptions} [options]
         * @returns {DatasetHeader}
         */
        static parseFromArray( array, options = {} ) {
            const { types = {}, encoders = [] } = options;
            const instance = new DatasetHeader();
            for ( const key of array ) {
                instance.addColumn( key, types[key], encoders.includes( key ) );
            }
            instance.nextIndex = array.length;
            return instance;
        }

    }

    class Dataset {

        /**
         * @typedef {Object} DatasetOptions
         * @property {Object} [types]
         * @property {String|Function} types.*
         * @property {String|String[]} [encoders]
         * @property {String|String[]} [excluded]
         */

        /**
         * @param {Array} elements
         * @param {Boolean} [fundamental]
         * @returns {void}
         */
        static log( elements, fundamental = true ) {
            console.log( `\n<-- ${ elements.length } ROWS -->` );
            if ( fundamental ) {
                if ( elements.length > 10 ) {
                    const first = elements.slice( 0, 5 );
                    const last = elements.slice( -5 );
                    for ( const item of first ) {
                        if ( Array.isArray( item[0] ) ) {
                            console.log( '[ ', item.map( k => (Array.isArray( k ) ? `\n  [ ${ k.join( ', ' ) } ]` : k) ).join( ', ' ), '\n]' );
                        }
                        else {
                            console.log( '[ ', item.join( ', ' ), ' ]' );
                        }
                    }
                    for ( let i = 0; i < 3; i += 1 ) {
                        console.log( '...' );
                    }
                    for ( const item of last ) {
                        if ( Array.isArray( item[0] ) ) {
                            console.log( '[ ', item.map( k => (Array.isArray( k ) ? `\n  [ ${k.join( ', ' )} ]` : k) ).join( ', ' ), '\n]' );
                        }
                        else {
                            console.log( '[ ', item.join( ', ' ), ' ]' );
                        }
                    }
                }
                else {
                    for ( const item of elements ) {
                        if ( Array.isArray( item[0] ) ) {
                            console.log( '[ ', item.map( k => (Array.isArray( k ) ? `\n  [ ${k.join( ', ' )} ]` : k) ).join( ', ' ), '\n]' );
                        }
                        else {
                            console.log( '[ ', item.join( ', ' ), ' ]' );
                        }
                    }
                }
            }
            else {
                const first = elements.slice( 0, 5 );
                const last = elements.slice( -5 );
                for ( const item of first ) {
                    console.log( item );
                }
                for ( let i = 0; i < 3; i += 1 ) {
                    console.log( '...' );
                }
                for ( const item of last ) {
                    console.log( item );
                }
            }
            console.log( `<-- ${ elements.length } ROWS -->\n` );
        }

        /**
         * @param {String} fileContentString
         * @returns {String[]}
         */
        static _getLines( fileContentString ) {
            return fileContentString.split( /\n/ug );
        }

        /**
         * @param {String[]} fileRowsStrings
         * @returns {Array<String[]>}
         */
        static _getCells( fileRowsStrings ) {
            return fileRowsStrings.map( row => row.replace( /\r/ug, '' ).split( /,/ug )
                .map( cell => cell.trim() ) );
        }

        /**
         * @param {Array<String[]>} fileCells2d
         * @returns {Array<String[]>}
         */
        static _getNotEmptyLines( fileCells2d ) {
            return fileCells2d.filter( row => row.length > 0 && row.some( cell => !!cell === true ) );
        }

        /**
         * @param {String|ArrayBuffer} fileContent
         * @returns {Array<String[]>}
         */
        static readFile( fileContent ) {
            /** @type {String} */
            let fileContentString;
            if ( fileContent instanceof ArrayBuffer ) {
                const decoder = new TextDecoder( 'utf-8' );
                fileContentString = decoder.decode( fileContent );
            }
            return Dataset._getNotEmptyLines(
                Dataset._getCells( Dataset._getLines( fileContentString || fileContent ) )
            );
        }

        /**
         * @param {Array<Number>} indexes
         * @param {Map<any,Map>|Map<any,any[]>|Array<any,Array[]>|Array[]} mappedData
         * @param {{
         *    sortFunctionMap:Map<Number,Function>,
         *    filterFunctionMap:Map<Number,Function>,
         *    groupByFilterFunctionMap:Map<Number,Function>
         * }} [options]
         * @returns {Array|Array[]|Map<String|Number,Array|Map>}
         */
        static _flat( indexes, mappedData, options = {} ) {
            const { sortFunctionMap, filterFunctionMap, groupByFilterFunctionMap } = options;
            const [ first, ...rest ] = indexes;
            if ( first !== undefined ) {
                let flat = mappedData;
                if ( flat instanceof Map ) {
                    flat = [ ...mappedData.keys() ];
                    if ( sortFunctionMap && sortFunctionMap.has( first ) ) {
                        let sortFunc;
                        if ( sortFunc = sortFunctionMap.get( first ) ) {
                            flat = flat.sort( sortFunc );
                        }
                    }
                    flat = flat.map( key => Dataset._flat( rest, mappedData.get( key ), { sortFunctionMap, filterFunctionMap, groupByFilterFunctionMap } ) );
                    if ( groupByFilterFunctionMap && groupByFilterFunctionMap.has( first ) ) {
                        let groupByFunc;
                        if ( groupByFunc = groupByFilterFunctionMap.get( first ) ) {
                            flat = flat.filter( groupByFunc );
                        }
                    }
                    flat = flat.flat( 1 );
                    if ( filterFunctionMap && filterFunctionMap.has( first ) ) {
                        let filterFunc;
                        if ( filterFunc = filterFunctionMap.get( first ) ) {
                            flat = flat.filter( filterFunc );
                        }
                    }
                    return flat;
                }
                else if ( Array.isArray( flat ) ) {
                    if ( filterFunctionMap && filterFunctionMap.has( first ) ) {
                        let filterFunc;
                        if ( filterFunc = filterFunctionMap.get( first ) ) {
                            flat = flat.filter( filterFunc );
                        }
                    }
                    if ( sortFunctionMap && sortFunctionMap.has( first ) ) {
                        let sortFunc;
                        if ( sortFunc = sortFunctionMap.get( first ) ) {
                            flat = flat.sort( ( a, b ) => sortFunc( a[first], b[first] ) );
                        }
                    }
                    return flat;
                }
                return mappedData;
            }
            return mappedData;
        }

        /**
         * @param {Array} rows
         * @param {Number[]} keys
         * @returns {Map<any,Map|Array>}
         */
        static _groupBy( rows, keys ) {

            const [ firstIndex, ...rest ] = keys;

            if ( firstIndex !== undefined && firstIndex >= 0 ) {

                /** @type Map */
                const result = rows.reduce( ( acc, curr ) => {
                    const key = curr[firstIndex];
                    const list = acc.has( key ) ? acc.get( key ) : [];
                    list.push( curr );
                    return acc.set( key, list );
                }, new Map() );

                if ( rest.length > 0 ) {
                    for ( const [ key, values ] of result.entries() ) {
                        result.set( key, Dataset._groupBy( values, rest ) );
                    }
                }

                return result;

            }
            return rows;
        }

        /**
         * @param {String|Function} [type]
         * @returns {Function}
         */
        static parseType( type ) {
            function toSame( value ) {
                return value === '' ? undefined : value;
            }
            if ( typeof type === 'function' ) {
                return function toCustom( value ) {
                    return type( value );
                };
            }
            switch ( type ) {
                case 'number': {
                    return function toNumber( value ) {
                        const newValue = toSame( value );
                        if ( newValue === undefined || Number.isNaN( +newValue ) ) {
                            return NaN;
                        }
                        return +newValue;
                    };
                }
                case 'bigint': {
                    return function toBigInt( value ) {
                        return BigInt( toSame( value ) );
                    };
                }
                case 'boolean': {
                    return function toBoolean( value ) {
                        const newValue = toSame( value );
                        return Number.isNaN( +newValue ) ? Boolean( newValue ) : !!+newValue;
                    };
                }
                case 'object': {
                    return function toObject( value ) {
                        return JSON.parse( toSame( value ) );
                    };
                }
                case 'string': {
                    return function toString( value ) {
                        return String( toSame( value ) );
                    };
                }
                default: {
                    return toSame;
                }
            }
        }

        /**
         * @param {String[]} header
         * @param {DatasetHeaderOptions} [options]
         * @returns {DatasetHeader}
         */
        static parseHeader( header, options ) {
            return new DatasetHeader( header, options );
        }

        /**
         * @param {String|RequestInfo} filePath
         * @param {DatasetOptions} [options]
         * @param {RequestInit} [requestOptions]
         * @returns {Dataset}
         */
        static load( filePath, options, requestOptions ) {
            return new Promise( ( resolve, reject ) => {
                fetch( filePath, requestOptions )
                    .then( response => {
                        if ( response.status === 200 && response.ok ) {
                            response
                                .text()
                                .then( fileContent => resolve( new Dataset( fileContent, options ) ) )
                                .catch( reject );
                        }
                        else {
                            reject( response );
                        }
                    } )
                    .catch( reject );
            } );
        }

        /**
         * @param {String|ArrayBuffer} fileContent
         * @param {DatasetOptions} [options]
         * @returns {Dataset}
         */
        constructor( fileContent, options = {} ) {
            const { excluded, encoders, types, slice: { start, end } = {} } = options;
            const [ header, ...rows ] = Dataset.readFile( fileContent );
            this.header = Dataset.parseHeader( header, { types, encoders } );
            this.rows = this.parseRows( start || end ? rows.slice( start || 0, end ) : rows, { excluded } );
        }

        /**
         * @returns {String[]}
         */
        get columns() {
            return this.header.columns;
        }

        /**
         * @param {String} key
         * @param {String|Function} typeSetting
         */
        setType( key, typeSetting ) {
            this.header.setColumnTypeByColumnKey( key, typeSetting );
            const { index, type } = this.header.getColumnByKey( key );
            this.rows.forEach( row => {
                row[index] = type( row[index] );
            } );
        }

        /**
         * @param {Array<Array<String,String|Function>>} types
         */
        setTypes( types ) {
            for ( const [ key, typeSetting ] of types ) {
                this.setType( key, typeSetting );
            }
        }

        /**
         * @param {String} key
         * @returns {Array}
         */
        getColumn( key ) {
            if ( this.header.hasColumn( key ) ) {
                const index = this.header.getColumnIndexByColumnKey( key );
                return this.rows.map( row => row[index] );
            }
            throw new Error();
        }

        /**
         * @param {String|String[]} keys
         * @returns {void}
         */
        removeColumns( keys ) {
            const _keys = Array.isArray( keys ) ? keys : [ keys ];
            const indexesToRemove = this.header.removeColumns( _keys );
            return new Promise( resolve => {
                this.mapAsync( row => row.filter( ( _, index ) => !indexesToRemove.includes( index ) ) )
                    .then( () => resolve( true ), console.error );
            } );
        }

        /**
         * @param {String[][]} rows
         * @param {Object} [options]
         * @param {String|String[]} options.excluded
         * @returns {Array[]}
         */
        parseRows( rows, options = {} ) {
            const { excluded } = options;
            const indexesToRemove = [];
            if ( excluded ) {
                indexesToRemove.push( ...this.header.removeColumns( excluded ) );
            }
            return rows.map( cells => cells
                .filter( ( _, i ) => !indexesToRemove.includes( i ) )
                .map( ( cell, i ) => {
                    const { encoder, type } = this.header.getColumnByIndex( i );
                    if ( encoder ) {
                        return encoder.getEncoded( type( cell ) );
                    }
                    return type( cell );

                } ) );
        }

        /**
         * @param {String} key
         * @returns {Array[]}
         */
        encodeColumn( key ) {
            const column = this.header.getColumnByKey( key );
            const { index, type } = column;
            let { encoder } = column;
            if ( !encoder ) {
                encoder = this.header.registerColumnEncoderByColumnKey( key );
            }
            for ( const row of this.rows ) {
                row[index] = encoder.getEncoded( type( row[index] ) );
            }
            return this.rows;
        }

        /**
         * @param {String[]} keys
         * @returns {Array[]}
         */
        encodeColumns( keys ) {
            const values = [];
            for ( const key of keys ) {
                const column = this.header.getColumnByKey( key );
                const { index, type } = column;
                let { encoder } = column;
                if ( !encoder ) {
                    encoder = this.header.registerColumnEncoderByColumnKey( key );
                }
                if ( encoder && index ) {
                    values.push( [ index, type, encoder ] );
                }
            }
            for ( const [ index, type, encoder ] of values ) {
                for ( const row of this.rows ) {
                    row[index] = encoder.getEncoded( type( row[index] ) );
                }
            }
            return this.rows;
        }

        /**
         * @param {String} key
         * @param {*} cell
         * @returns {Number}
         */
        encodeCell( key, cell ) {
            const { type, encoder } = this.header.getColumnByKey( key );
            if ( encoder ) {
                cell = encoder.getEncoded( type( cell ) );
                return cell;
            }
        }

        /**
         * @param {String} key
         * @param {Array} cells
         * @returns {Number[]}
         */
        encodeCells( key, cells ) {
            const { type, encoder } = this.header.getColumnByKey( key );
            if ( encoder ) {
                cells = cells.map( cell => encoder.getEncoded( type( cell ) ) );
                return cells;
            }
        }

        /**
         * @param {String} key
         * @returns {Array[]}
         */
        decodeColumn( key ) {
            const { index, encoder } = this.header.getColumnByKey( key );
            for ( const row of this.rows ) {
                row[index] = encoder.getDecoded( row[index] );
            }
            return this.rows;
        }

        /**
         * @param {String[]} keys
         * @returns {Array[]}
         */
        decodeColumns( keys ) {
            const values = [];
            for ( const key of keys ) {
                const { index, encoder } = this.header.getColumnByKey( key );
                if ( encoder ) {
                    values.push( [ index, encoder ] );
                }
            }
            for ( const [ index, encoder ] of values ) {
                for ( const row of this.rows ) {
                    row[index] = encoder.getDecoded( row[index] );
                }
            }
            return this.rows;
        }

        /**
         * @param {String} key
         * @param {*} cell
         * @returns {*}
         */
        decodeCell( key, cell ) {
            const encoder = this.header.getColumnEncoderByColumnKey( key );
            if ( encoder ) {
                cell = encoder.getDecoded( cell );
                return cell;
            }
        }

        /**
         * @param {String} key
         * @param {Array} cells
         * @returns {Array}
         */
        decodeCells( key, cells ) {
            const encoder = this.header.getColumnEncoderByColumnKey( key );
            if ( encoder ) {
                cells = cells.map( cell => encoder.getDecoded( cell ) );
                return cells;
            }
        }

        /**
         * @typedef {Object} DatasetColumnStatistics
         * @property {Number} *
         *
         * @param {*} object
         * @param {String|String[]} keys
         * @returns {DatasetColumnStatistics}
         */
        count( object, keys ) {
            const _keys = Array.isArray( keys ) ? keys : [ keys ];
            const indexes = {};
            const results = {};
            _keys.forEach( key => indexes[key] = this.header.getColumnIndexByColumnKey( key ) );
            _keys.forEach( key => results[key] = [] );
            this.forEach( ( element, index ) => {
                for ( const key in indexes ) {
                    if ( Object.is( element[indexes[key]], object ) ) {
                        results[key].push( index );
                    }
                }
            } );
            results[Symbol( 'target' )] = object;
            return results;
        }

        /**
         * @param {*} object
         * @param {String|String[]} keys
         * @returns {Promise<DatasetColumnStatistics>}
         */
        async countAsync( object, keys ) {
            const _keys = Array.isArray( keys ) ? keys : [ keys ];
            const indexes = {};
            const results = {};
            _keys.forEach( key => indexes[key] = this.header.getColumnIndexByColumnKey( key ) );
            _keys.forEach( key => results[key] = [] );
            return new Promise( resolve => {
                this.forEachAsync( ( element, index ) => {
                    for ( const key in indexes ) {
                        if ( Object.is( element[indexes[key]], object ) ) {
                            results[key].push( index );
                        }
                    }
                } ).then( () => {
                    results[Symbol( 'target' )] = object;
                    resolve( results );
                } );
            } );
        }

        /**
         * @param {String[]} keys
         * @returns {Map}
         */
        groupBy( keys ) {
            return Dataset._groupBy( this.rows, keys.some( k => typeof k === 'string' ) ? keys.map( key => this.header.getColumnIndexByColumnKey( key ) ) : keys );
        }

        /**
         * @param {Array<Array<String|Number,Function|String|undefined>>} keys
         * @param {Boolean} [inplace]
         * @returns {Array<Array>}
         */
        sortBy( keys, inplace = true ) {
            /**
             * @param {String|Function|undefined} [type]
             * @returns {Function}
             */
            function sortParse( type ) {
                if ( typeof type === 'function' ) {
                    return type;
                }
                switch ( `${ type }`.toLowerCase() ) {
                    case 'd':
                    case 'desc':
                    case 'descending':
                    case 'za':
                    case 'z-a': {
                        return ( a, b ) => b - a;
                    }
                    default: {
                        return ( a, b ) => a - b;
                    }
                }

            }
            let indexes;
            let sortFunctionMap;

            if ( typeof keys === 'string' ) {
                keys = [ keys ];
            }

            if ( keys.some( k => typeof k === 'string' ) ) {
                keys = keys.map( k => (typeof k === 'string' ? [this.header.getColumnIndexByColumnKey( k )] : [k]) );
            }

            [ indexes, sortFunctionMap ] = ( keys.some( ( [ k ] ) => typeof k === 'string' ) ?
                keys.map( ( [ k, s ] ) => [ this.header.getColumnIndexByColumnKey( k ), sortParse( s ) ] ) :
                keys.map( ( [ i, s ] ) => [ i, sortParse( s ) ] ) )
                .reduce( ( p, c, i ) => {
                    p[0][i] = c[0];
                    p[1].set( c[0], c[1] );
                    return p;
                }, [ [], new Map() ] );

            if ( keys.length > 1 ) {
                const grouped = Dataset._groupBy( this.rows, indexes );
                const flatted = Dataset._flat( indexes, grouped, { sortFunctionMap } );
                if ( inplace ) {
                    this.rows = flatted;
                    return this.rows;
                }
                return flatted;
            }
            const [ index ] = indexes;
            if ( sortFunctionMap.has( index ) ) {
                let sortFunc;
                if ( sortFunc = sortFunctionMap.get( index ) ) {
                    if ( inplace ) {
                        return this.rows.sort( ( a, b ) => sortFunc( a[index], b[index] ) );
                    }
                    return [ ...this.rows ].sort( ( a, b ) => sortFunc( a[index], b[index] ) );

                }
            }

            return this.rows;
        }

        /**
         * @param {Array<Array<String|Number,Function>>} keyFilters
         * @param {Array<Array<String|Number,Function>>} [groupByFilters]
         * @param {Boolean} [inplace]
         * @returns {Array<Array>}
         */
        filter( keyFilters, groupByFilters, inplace = true ) {

            if ( typeof keyFilters === 'function' ) {
                return this.rows = this.rows.filter( keyFilters );
            }

            let indexes;
            let filterFunctionMap;
            let groupByFilterFunctionMap;

            [ indexes, filterFunctionMap ] = ( keyFilters.some( ( [ k ] ) => typeof k === 'string' ) ?
                keyFilters.map( ( [ k, s ] ) => [ this.header.getColumnIndexByColumnKey( k ), s ] ) :
                keyFilters.map( ( [ i, s ] ) => [ i, s ] ) )
                .reduce( ( p, [ k, f ], i ) => ( p[0][i] = k, p[1].set( k, f ), p ), [ [], new Map() ] );

            if ( groupByFilters ) {
                groupByFilterFunctionMap = ( groupByFilters.some( ( [ k ] ) => typeof k === 'string' ) ?
                    groupByFilters.map( ( [ k, s ] ) => [ this.header.getColumnIndexByColumnKey( k ), s ] ) :
                    groupByFilters.map( ( [ i, s ] ) => [ i, s ] ) )
                    .reduce( ( p, [ k, f ] ) => p.set( k, f ), new Map() );
            }

            if ( keyFilters.length > 1 ) {
                const grouped = Dataset._groupBy( this.rows, indexes );
                const flatted = Dataset._flat( indexes, grouped, { filterFunctionMap, groupByFilterFunctionMap } );
                if ( inplace ) {
                    this.rows = flatted;
                    return this.rows;
                }
                return flatted;
            }
            const [ index ] = indexes;
            if ( filterFunctionMap.has( index ) ) {
                const filterFunc = filterFunctionMap.get( index );
                if ( filterFunc ) {
                    const filtered = this.rows.filter( filterFunc );
                    if ( inplace ) {
                        this.rows = filtered;
                        return this.rows;
                    }
                    return filtered;
                }
            }
            return this.rows;

        }

        /**
         * @callback callback
         * @param {Array} element
         * @param {Number} index
         * @param {Array[]} array
         * @returns {void}
         */
        /**
         * @param {callback} callback
         * @param {Array} [thisArg]
         * @returns {void}
         */
        forEach( callback, thisArg = this.rows ) {
            for ( let i = 0, l = this.rows.length; i < l; i += 1 ) {
                callback( this.rows[i], i, thisArg );
            }
        }

        /**
         * @callback callback
         * @param {Array} element
         * @param {Number} index
         * @param {Array[]} array
         * @returns {void}
         */
        /**
         * @param {callback} callback
         * @param {Array} [thisArg]
         * @returns {void}
         */
        async forEachAsync( callback, thisArg = this.rows ) {
            for ( let i = 0, l = this.rows.length; i < l; i += 1 ) {
                callback( this.rows[i], i, thisArg );
            }
        }

        /**
         * @callback callback
         * @param {Array} element
         * @param {Number} index
         * @param {Array[]} array
         */
        /**
         * @param {callback} callback
         * @param {{inplace:Boolean,thisArg:Array[]}} [options]
         * @returns {Array}
         */
        map( callback, options = {} ) {
            const { inplace, thisArg = this.rows } = options;
            if ( inplace ) {
                for ( let i = 0, l = this.rows.length; i < l; i += 1 ) {
                    this.rows[i] = callback( this.rows[i], i, thisArg );
                }
                return this.rows;
            }

            const rows = [];
            for ( let i = 0, l = this.rows.length; i < l; i += 1 ) {
                rows[i] = callback( this.rows[i], i, thisArg );
            }
            return rows;

        }

        /**
         * @callback callback
         * @param {Array} element
         * @param {Number} index
         * @param {Array[]} array
         */
        /**
         * @param {callback} callback
         * @param {{inplace:Boolean,thisArg:Array[]}} [options]
         * @returns {Array}
         */
        async mapAsync( callback, options = {} ) {
            const { inplace, thisArg = this.rows } = options;
            if ( inplace ) {
                for ( let i = 0, l = this.rows.length; i < l; i += 1 ) {
                    this.rows[i] = callback( this.rows[i], i, thisArg );
                }
                return this.rows;
            }

            const rows = [];
            for ( let i = 0, l = this.rows.length; i < l; i += 1 ) {
                rows[i] = callback( this.rows[i], i, thisArg );
            }
            return rows;

        }

    }

    var dataset = { Dataset, DatasetEncoder, DatasetHeader };

    /* eslint-env module */

    /**
     * @param  {...Function} funcs
     * @returns {Function}
     */
    function pipe( ...funcs ) {
        if ( funcs.length > 0 ) {
            return funcs.reduce( ( acc, curr ) => arg => curr( acc( arg ) ) );
        }
        throw new Error( 'No function passed.' );
    }

    /**
     * @param  {...Function} funcs
     * @returns {Function}
     */
    function compose( ...funcs ) {
        if ( funcs.length > 0 ) {
            return funcs.reduceRight( ( acc, curr ) => arg => curr( acc( arg ) ) );
        }
        throw new Error( 'No function passed.' );
    }

    class IArray {

        static toImmutable( thisArg ) {
            if ( !IArray.isIArray( thisArg ) ) {
                if (
                    Array.isArray( thisArg ) ||
                    Symbol.iterator in thisArg &&
                    typeof thisArg.length !== 'undefined' &&
                    typeof thisArg[0] !== 'undefined'
                ) {
                    return Object.freeze( Object.setPrototypeOf( thisArg, IArray.prototype ) );
                }

                throw new TypeError( 'Please use IArray.from' );

            }
            else {
                return Object.freeze( thisArg );
            }
        }

        static from( ...args ) {
            switch ( args.length ) {
                case 0: {
                    throw new Error( 'What\'s the point of creating an Immutable 0-sized ?' );
                }
                case 1: {
                    const Mutable = [];
                    const IterableSource = args[0];
                    if ( IterableSource && Symbol.iterator in IterableSource ) {
                        const Iterator = IterableSource[Symbol.iterator]();
                        let value;
                        let done;
                        while ( !( { value, done } = Iterator.next(), done ) ) {
                            Mutable.push( value );
                        }
                    }
                    else if ( IterableSource && typeof IterableSource === 'object' ) {
                        for ( const property in IterableSource ) {
                            if ( Object.prototype.hasOwnProperty.call( IterableSource, property ) ) {
                                Mutable.push( IterableSource[property] );
                            }
                        }
                    }
                    return IArray.toImmutable( Mutable );
                }
                default: {
                    return new IArray( ...args );
                }
            }
        }

        static isIArray( instance ) {
            return Object.getPrototypeOf( instance ) === IArray.prototype &&
                'length' in instance &&
                ( !Object.isExtensible( instance ) || Object.isFrozen( instance ) );
        }

        static [Symbol.hasInstance]( instance ) {
            return IArray.isIArray( instance );
        }

        static isCollapsable( instance ) {
            return IArray.isIArray( instance ) || Array.isArray( instance );
        }

        static isResizable( instance ) {
            return Object.isExtensible( instance );
        }

        static isImmutable( instance ) {
            return Object.isFrozen( instance );
        }

        constructor( ...args ) {
            const { length } = args;
            if ( length === 1 && typeof args[0] === 'number' ) {
                this.length = args[0];
            }
            else {
                this.length = length;
                for ( let i = 0; i < length; i += 1 ) {
                    this[i] = args[i];
                }
                Object.freeze( this );
            }
        }

        [Symbol.iterator]() {
            const { length } = this;
            let i = 0;
            return {
                next: () => ( {
                    value: i < length ? this[i] : undefined,
                    done: i++ >= length
                } )
            };
        }

        toString() {
            const { length } = this;
            if ( length === 0 ) {
                return '';
            }

            let outputString = `${ this[0] }`;
            for ( let i = 1; i < length; i += 1 ) {
                outputString += `,${ this[i] }`;
            }
            return outputString;

        }

        /**
         * @returns {Number}
         */
        deepLength() {
            const { length } = this;
            let _length = length;
            for ( let i = 0; i < length; i += 1 ) {
                if ( IArray.isCollapsable( this[i] ) ) {
                    _length += IArray.prototype.deepLength.call( this[i] ) - 1;
                }
            }
            return _length;
        }

        initialize() {
            if ( IArray.isImmutable( this ) ) {
                throw new Error( 'As an immutable data structure, <initialize> method can not be called on it.' );
            }
            for ( let i = 0, { length } = this; i < length; i += 1 ) {
                this[i] = null;
            }
            return Object.preventExtensions( this );

        }

        /**
         * @param {any} value
         * @returns {IArray}
         */
        fill( value, start, end ) {
            if ( IArray.isImmutable( this ) ) {
                throw new Error( 'As an immutable data structure, <fill> method can not be called on it.' );
            }
            else {
                const { length } = this;
                const _start = typeof start !== 'undefined' && start >= 0 && start < length ? start < end ? start : end : 0;
                const _end = typeof end !== 'undefined' && end >= 0 && end < length ? end > start ? end : start : length;
                for ( let i = _start; i < _end; i += 1 ) {
                    this[i] = value;
                }
                return Object.freeze( this );
            }
        }

        /**
         * @param {Function} value
         * @returns {IArray}
         */
        populate( callback ) {
            if ( IArray.isImmutable( this ) ) {
                throw new Error( 'As an immutable data structure, <populate> method can not be called on it.' );
            }
            else {
                for ( let i = 0, { length } = this; i < length; i += 1 ) {
                    this[i] = callback( i, this );
                }
                return Object.freeze( this );
            }
        }

        /**
         * @param {Number} i
         * @returns {any}
         */
        at( i ) {
            return i < 0 ? this[this.length + i] : i;
        }

        /**
         * @returns {Iterable<any>}
         */
        values() {
            return { [Symbol.iterator]: this[Symbol.iterator] };
        }

        /**
         * @returns {Iterable<Number,any>}
         */
        entries() {
            return {
                [Symbol.iterator]: () => {
                    const { length } = this;
                    let i = 0;
                    return {
                        next: () => ( {
                            value: i < length ? new IArray( i, this[i] ) : undefined,
                            done: i++ >= length
                        } )
                    };
                }
            };
        }

        /**
         * @returns {Iterable<Number>}
         */
        keys() {
            return {
                [Symbol.iterator]: () => {
                    const { length } = this;
                    let i = 0;
                    return {
                        next: () => ( {
                            value: i < length ? i : undefined,
                            done: i++ >= length
                        } )
                    };
                }
            };
        }

        /**
         * @param {Function} callback
         * @param {IArray} thisArg
         */
        forEach( callback, thisArg ) {
            const _thisArg = thisArg || this;
            for ( let i = 0, { length } = _thisArg; i < length; i += 1 ) {
                callback( _thisArg[i], i, _thisArg );
            }
        }

        includes( valueToFind, fromIndex ) {
            for ( let { length } = this, i = fromIndex >= 0 && fromIndex < length ? fromIndex : 0; i < length; i += 1 ) {
                if ( Object.is( this[i], valueToFind ) ) {
                    return true;
                }
            }
            return false;
        }

        indexOf( searchElement, fromIndex ) {
            for ( let { length } = this, i = fromIndex >= 0 && fromIndex < length ? fromIndex : 0; i < length; i += 1 ) {
                if ( Object.is( this[i], searchElement ) ) {
                    return i;
                }
            }
            return -1;
        }

        /**
         * @param {any} searchElement
         * @param {Number} fromIndex
         * @returns {Number}
         */
        lastIndexOf( searchElement, fromIndex ) {
            for ( let { length } = this, i = fromIndex >= 0 && fromIndex < length ? fromIndex : length; i > 0; i -= 1 ) {
                if ( Object.is( this[i], searchElement ) ) {
                    return i;
                }
            }
            return -1;
        }

        map( callback, thisArg ) {
            const _thisArg = thisArg || this;
            return new IArray( _thisArg.length ).populate( index => callback( _thisArg[index], index, _thisArg ) );
        }

        reduce( callback, initialValue ) {
            let accumulator = initialValue || this[0];
            for ( let i = 0, { length } = this; i < length; i += 1 ) {
                accumulator = callback( accumulator, this[i], i, this );
            }
            return accumulator;
        }

        reduceRight( callback, initialValue ) {
            const { length } = this;
            let accumulator = initialValue || this[length - 1];
            for ( let i = length; i > 0; i -= 1 ) {
                accumulator = callback( accumulator, this[i], i, this );
            }
            return accumulator;
        }

        filter( callback, thisArg ) {
            const _thisArg = thisArg || this;
            const { length } = _thisArg;
            const Mutable = [];
            for ( let i = 0; i < length; i += 1 ) {
                if ( callback( _thisArg[i], i, _thisArg ) ) {
                    Mutable.push( _thisArg[i] );
                }
            }
            return IArray.toImmutable( Mutable );
        }

        every( callback, thisArg ) {
            const _thisArg = thisArg || this;
            for ( let i = 0, { length } = _thisArg; i < length; i += 1 ) {
                if ( !callback( _thisArg[i], i, _thisArg ) ) {
                    return false;
                }
            }
            return true;
        }

        some( callback, thisArg ) {
            const _thisArg = thisArg || this;
            const { length } = _thisArg;
            for ( let i = 0; i < length; i += 1 ) {
                if ( callback( _thisArg[i], i, _thisArg ) ) {
                    return true;
                }
            }
            return false;
        }

        find( callback, thisArg ) {
            const _thisArg = thisArg || this;
            const { length } = _thisArg;
            for ( let i = 0; i < length; i += 1 ) {
                if ( callback( _thisArg[i], i, _thisArg ) ) {
                    return _thisArg[i];
                }
            }
            return undefined;
        }

        findIndex( callback, thisArg ) {
            const _thisArg = thisArg || this;
            const { length } = _thisArg;
            for ( let i = 0; i < length; i += 1 ) {
                if ( callback( _thisArg[i], i, _thisArg ) ) {
                    return i;
                }
            }
            return -1;
        }

        reverse() {
            const { length } = this;
            const Mutable = new IArray( length );
            for ( let i = 1; i <= length; i += 1 ) {
                Mutable[i - 1] = this[length - i];
            }
            return Object.freeze( Mutable );
        }

        slice( start, end ) {
            const { length } = this;
            const _start = start >= 0 && start < length ? start : 0;
            const _end = end >= 0 && end <= length ? end : length;
            const _length = _end - _start;
            const Mutable = new IArray( _length );
            let _i = 0;
            for ( let i = _start; i < _end; i += 1 ) {
                Mutable[_i++] = this[i];
            }
            return Object.freeze( Mutable );
        }

        splice( start, deleteCount, ...items ) {
            const { length } = this;
            const { length: _length } = items;
            let count = typeof deleteCount === 'undefined' ? length - start : deleteCount >= 0 ? deleteCount : 0;
            const mLength = length - count + _length;
            console.log( mLength );
            const Mutable = new IArray( mLength );
            let _i = 0;
            for ( let i = 0; i < length; i += 1 ) {
                if ( i === start ) {
                    if ( _length ) {
                        for ( let j = 0; j < _length; j += 1 ) {
                            Mutable[_i++] = items[j];
                            if ( ( count -= 1 ) > 0 ) {
                                i += 1;
                            }
                        }
                    }
                }
                else if ( i > start ) {
                    while ( ( count -= 1 ) > 0 && i < length ) {
                        i += 1;
                    }
                    if ( i < length ) {
                        Mutable[_i++] = this[i];
                    }
                }
                else {
                    Mutable[_i++] = this[i];
                }
            }
            return Object.freeze( Mutable );
        }

        flatMap( callback, thisArg ) {
            const _thisArg = thisArg || this;
            const { length } = _thisArg;
            const Mutable = [];
            for ( let i = 0; i < length; i += 1 ) {
                const item = callback( _thisArg[i], i, _thisArg );
                if ( IArray.isCollapsable( item ) ) {
                    for ( let j = 0, { length: _length } = item; i < _length; i += 1 ) {
                        if ( typeof item[j] !== 'undefined' ) {
                            Mutable.push( item[_j] );
                        }
                    }
                }
                else if ( typeof item !== 'undefined' ) {
                    Mutable.push( item );
                }
            }
            return IArray.toImmutable( Mutable );
        }

        flat( depth ) {
            const Mutable = [];
            for ( let i = 0, { length } = this; i < length; i += 1 ) {
                if ( depth > 1 && IArray.isCollapsable( this[i] ) ) {
                    const _item = this[i].flat( depth - 1 );
                    for ( let j = 0, { length } = _item; j < length; j += 1 ) {
                        Mutable.push( _item[j] );
                    }
                }
                else {
                    Mutable.push( this[i] );
                }
            }
            return IArray.toImmutable( Mutable );
        }

        concat( ...args ) {
            const Mutable = [];
            for ( let i = 0, { length } = this; i < length; i += 1 ) {
                Mutable.push( this[i] );
            }
            for ( let i = 0, { length } = args; i < length; i += 1 ) {
                if ( IArray.isCollapsable( args[i] ) ) {
                    for ( let ai = 0, { length } = args[i]; ai < length; ai += 1 ) {
                        Mutable.push( args[ai] );
                    }
                }
                else {
                    Mutable.push( args[i] );
                }
            }
            return IArray.toImmutable( Mutable );
        }



        copyWithin( target, start, end ) {
            const { length } = this;
            const Mutable = new IArray( length );
            if ( target > length ) {
                for ( let i = 0; i < length; i += 1 ) {
                    Mutable[i] = this[i];
                }
                return IArray.toImmutable( Mutable );
            }
            const _start = typeof start === 'undefined' ? 0 : start < 0 ? length + start : start > length ? length : start;
            const _end = typeof end === 'undefined' ? length : end < 0 ? length + end : end > length ? length : end;
            let _index = 0;
            let [ toCopy, startCopy ] = _start < _end ? [ _end - _start, _start ] : [ _start - _end, _end ];
            for ( let i = 0; i < length; i += 1 ) {
                if ( i >= target && toCopy-- > 0 ) {
                    Mutable[_index] = this[startCopy++];
                }
                else {
                    Mutable[_index] = this[i];
                }
                _index += 1;
            }
            return IArray.toImmutable( Mutable );
        }

        join( separator ) {
            const { length } = this;
            let string = '';
            for ( let i = 0; i < length; i += 1 ) {
                string = `${ string }${ separator }${ this[i] }`;
            }
            return string;
        }

        sort( callback ) {
            callback = callback || ( ( a, b ) => a < b ? -1 : a > b ? 1 : 0 );
            const { length } = this;
            if ( length <= 1 ) {
                return IArray.from( this );
            }
            const middle = Math.floor( length / 2 );
            const left = this.slice( 0, middle );
            const right = this.slice( middle );

            function merge( left, right ) {
                const { length: ll } = left;
                const { length: rl } = right;
                const Mutable = new IArray( ll + rl );
                let globalIndex = 0;
                let leftIndex = 0;
                let rightIndex = 0;
                while ( leftIndex < ll && rightIndex < rl ) {
                    if ( callback( left[leftIndex], right[rightIndex] ) < 0 ) {
                        Mutable[globalIndex++] = left[leftIndex++];
                    }
                    else {
                        Mutable[globalIndex++] = right[rightIndex++];
                    }
                }

                for ( let i = leftIndex; i < ll; i += 1 ) {
                    Mutable[globalIndex++] = left[i];
                }
                for ( let i = rightIndex; i < rl; i += 1 ) {
                    Mutable[globalIndex++] = right[i];
                }

                return IArray.toImmutable( Mutable );
            }
            return merge( left.sort( callback ), right.sort( callback ) );

        }

        reshape( ...args ) {
            const { length } = args;
            if ( length === 0 ) {
                return this.flat( Infinity );
            }
            let array = this.flat( Infinity );
            const { length: fLength } = array;
            if ( length >= 1 && ( fLength % args.reduce( ( acc, curr ) => acc * curr ) !== 0 || fLength % args[0] !== 0 ) ) {
                throw new RangeError( `An array of shape (${ fLength }, 1)  can not be converted to an array of shape (${ args.join( ',' ) })` );
            }
            for ( let i = length - 1; i >= 0; i -= 1 ) {
                const dimension = args[i];
                const _length = array.length / dimension;
                array = new IArray( _length ).populate( i => new IArray( dimension ).populate( j => array[i * dimension + j] ) );
            }
            return array;
        }

        push( ...args ) {
            const { length } = this;
            const { length: _length } = args;
            const _sum = length + _length;
            if ( IArray.isImmutable( this ) ) {
                const Mutable = new IArray( _sum );
                for ( let i = 0; i < length; i += 1 ) {
                    Mutable[i] = this[i];
                }
                for ( let i = 0; i < _length; i += 1 ) {
                    Mutable[i + length] = args[i];
                }
                return Object.freeze( Mutable );
            }
            if ( IArray.isResizable( this ) ) {
                for ( let i = 0; i < _length; i += 1 ) {
                    this[length + i] = args[i];
                }
                this.length = _sum;
                return this;
            }
            throw new Error( 'What the fuck are you doing ?' );
        }

        empty() {
            if ( IArray.isImmutable( this ) ) {
                throw new TypeError( 'As an immutable data structure, <empty> method can not be called on it.' );
            }
            else {
                for ( let i = 0, { length } = this; i < length; i += 1 ) {
                    this[i] = null;
                }
            }
            return this;
        }

    }

    var functional = { pipe, compose, IArray };

    /* eslint-env module */


    const Cookies = {
        /**
         * @returns {String} Datetime One Year Later
         */
        expires() {
            const newDate = new Date();
            const year = 365.244 * 24 * 3600 * 1000;
            newDate.setTime( newDate.getTime() + year );
            return newDate.toGMTString();
        },
        /**
         * @param {String} cookieName - Name of the cookie
         * @returns {String} Cookie Value
         */
        get( cookieName ) {
            return new Map(
                decodeURIComponent( document.cookie )
                    .split( /;/u )
                    .map( str => str.trim().split( /[=]/u ) )
            ).get( cookieName );
        },
        /**
         * @param {String} cookieName - Name of the cookie
         * @returns {Boolean} - True if cookie exists
         */
        has( cookieName ) {
            return new Map(
                decodeURIComponent( document.cookie )
                    .split( /;/u )
                    .map( str => str.trim().split( /[=]/u ) )
            ).has( cookieName );
        },
        /**
         * @typedef {Object} CookieOptions - Options for the cookie
         * @property {Number} expiration - Number of days until expiration
         * @property {'Strict'|'Lax'|'None'} sameSite - Cookie SameSite policy
         * @property {String} path - Cookie path
         */
        /**
         * @param {String} cookieName - Name of the cookie
         * @param {String|Number|Boolean} cookieValue - Value of the cookie
         * @param {CookieOptions} [options] - Options to set with the cookie
         */
        set( cookieName, cookieValue, options = {} ) {
            const newExpiration = this.expires();
            const {
                expiration = newExpiration,
                sameSite = 'Strict',
                path = '/'
            } = options;
            const cookieString = [ `${ cookieName }=${ encodeURIComponent( cookieValue ) }` ];
            cookieString.push( `expires=${ expiration }` );
            cookieString.push( `path=${ path }` );
            cookieString.push( `SameSite=${ sameSite };Secure` );
            document.cookie = cookieString.join( ';' );
        },

        /**
         * @param {String} cookieName - Name of the cookie
         */
        delete( cookieName ) {
            document.cookie = `${ cookieName }=;expires=0;`;
        }
    };

    class WebPTest {

        static get data() {
            return [
                [
                    'lossy',
                    'UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'
                ],
                [
                    'lossless',
                    'UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA=='
                ],
                [
                    'alpha',
                    'UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA=='
                ],
                [
                    'animation',
                    'UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA'
                ]
            ];
        }

        static save( features ) {
            const gl = getGlobal();
            gl.WebPTestResult = features.reduce( ( acc, [ feature, bool ] ) => {
                if ( !( feature in acc ) ) {
                    acc[feature] = bool;
                }
                return acc;
            }, Object.create( null ) );
            return gl.WebPTestResult;
        }

        static imageLoading( data, feature ) {
            return new Promise( resolve => {
                const img = new Image();
                img.onload = function onload() {
                    resolve( [ feature, img.width > 0 && img.height > 0 ] );
                };
                img.onerror = function onerror() {
                    resolve( [ feature, false ] );
                };
                img.src = data;
            } );
        }

        static test() {
            const gl = getGlobal();
            return new Promise( resolve => {
                if ( 'WebPTestResult' in gl ) {
                    resolve( gl.WebPTestResult );
                }
                else {
                    Promise.all(
                        WebPTest.data.map( ( [ feature, data ] ) => WebPTest.imageLoading( `data:image/webp;base64,${ data }`, feature ) )
                    ).then( response => {
                        resolve( WebPTest.save( response ) );
                    } );
                }
            } );
        }

        static get passed() {
            const gl = getGlobal();
            let wtr;
            return new Promise( async resolve => {
                if ( 'WebPTestResult' in gl ) {
                    wtr = gl.WebPTestResult;
                }
                else {
                    wtr = await WebPTest.test();
                }
                resolve( wtr.lossy && wtr.lossless && wtr.alpha && wtr.animation );
            } );
        }

    }

    var navigator = {
        Cookies,
        WebPTest
    };

    /* eslint-env module */

    class Wait {

        /**
         * @typedef {Object} WaitRegister
         * @property {Array<Function>} DOMContentLoaded
         * @property {Array<Function>} interactive
         * @property {Array<Function>} complete
         * @property {Array<Function>} load
         */
        /**
         * @typedef {'DOMContentLoaded'|'interactive'|'complete'|'load'} WaitRegisterType
         */
        /**
         * @returns {WaitRegister}
         */
        static register() {
            const gl = getGlobal$1();
            if ( typeof gl.WaitRegister === 'undefined' ) {
                gl.WaitRegister = {
                    interactive: [],
                    complete: [],
                    DOMContentLoaded: [],
                    load: []
                };
                document.addEventListener( 'readystatechange', () => Wait.all( document.readyState ) );
                document.addEventListener( 'DOMContentLoaded', () => Wait.all( 'DOMContentLoaded' ) );
                window.addEventListener( 'load', () => Wait.all( 'load' ) );
            }
            return gl.WaitRegister;
        }

        /**
         * @typedef {Object} WaitRegisterOptions
         * @property {Function} resolve
         * @property {Function} reject
         * @property {Function} func
         * @property {any[]} args
         */

        /**
         * @param {string} type - Register an action to be fired when type is dispatched
         * @param {WaitRegisterOptions} options - Functions and args to call when action will be fired
         */
        static set( type, options ) {
            const { resolve, reject, func, args } = options;
            const registry = Wait.register();
            let exec = false;
            const { readyState } = document;
            switch ( type ) {
                case 'interactive':
                case 'DOMContentLoaded': {
                    if ( readyState !== 'loading' ) {
                        exec = true;
                        try {
                            resolve( func( ...args ) );
                        }
                        catch ( _ ) {
                            reject( _ );
                        }
                    }
                    break;
                }
                case 'complete':
                case 'load': {
                    if ( readyState === 'complete' ) {
                        exec = true;
                        try {
                            resolve( func( ...args ) );
                        }
                        catch ( _ ) {
                            reject( _ );
                        }
                    }
                    break;
                }
            }
            if ( exec === false ) {
                registry[type].push( () => new Promise( ( resolve_, reject_ ) => {
                    try {
                        return resolve_( resolve( func( ...args ) ) );
                    }
                    catch ( _ ) {
                        reject_( reject( _ ) );
                    }
                } ) );
            }
        }

        /**
         * @param {WaitRegisterType} type - EventType or Key to wait to be dispatched or already registered
         * @returns {Promise<any[]>} Wrap every function of a type in a Promise.all and return the result
         */
        static all( type ) {
            return Promise.all( Wait.register()[type].map( f => f() ) );
        }

        /**
         * @param {Number} time - Time to wait before resolving
         * @returns {Promise<Number>} Resolve after time
         */
        static time( time ) {
            return new Promise( resolve => setTimeout( resolve, time ) );
        }

        /**
         *
         * @param {Function} func - Function to wrap in a setTimeout function
         * @param {Number} timeout - timeout parameter for setTimeout
         * @param  {...any} funcArgs - Arguments to pass to func function
         * @returns {Number} Timeout ID
         */
        static delay( func, timeout, ...funcArgs ) {
            return setTimeout( func, timeout || 0, ...funcArgs );
        }

        /**
         *
         * @param {Function} func - Function to wrap in a Promise
         * @param  {...any} funcArgs - Arguments to pass to function
         * @returns {Promise} Asynchronous wrapped function
         */
        static async( func, ...funcArgs ) {
            return new Promise( ( resolve, reject ) => {
                try {
                    resolve( func( ...funcArgs ) );
                }
                catch ( _ ) {
                    reject( _ );
                }
            } );
        }

        /**
         *
         * @param {Function} func - Function to wrap in an asynchronous timeout
         * @param {Number} timeout - Timeout to wait before calling func
         * @param  {...any} funcArgs - Arguments to pass to func
         * @returns {Promise} Asynchronous wrapped function
         */
        static promiseDelay( func, timeout, ...funcArgs ) {
            return new Promise( ( resolve, reject ) => setTimeout( ( ...args ) => {
                try {
                    return resolve( func( ...args ) );
                }
                catch ( _ ) {
                    return reject( _ );
                }
            }, timeout, ...funcArgs ) );
        }

        /**
         *
         * @param {Function} func - Function to trigger when interactive event is fired
         * @param  {...any} funcArgs - Arguments to pass to function
         * @returns {Promise} Asynchronous wrapped function
         */
        static interactive( func, ...funcArgs ) {
            return new Promise( ( resolve, reject ) => {
                Wait.set( 'interactive', { resolve, reject, func, args: funcArgs } );
            } );
        }

        /**
         *
         * @param {Function} func - Function to trigger when readyState changes to complete
         * @param  {...any} funcArgs - Arguments to pass to function
         * @returns {Promise} Asynchronous wrapped function
         */
        static complete( func, ...funcArgs ) {
            return new Promise( ( resolve, reject ) => {
                Wait.set( 'complete', { resolve, reject, func, args: funcArgs } );
            } );
        }

        /**
         *
         * @param {Function} func - Function to trigger when DOMContentLoaded event is fired
         * @param  {...any} funcArgs - Arguments to pass to function
         * @returns {Promise} Asynchronous wrapped function
         */
        static DOMContentLoaded( func, ...funcArgs ) {
            return new Promise( ( resolve, reject ) => {
                Wait.set( 'DOMContentLoaded', { resolve, reject, func, args: funcArgs } );
            } );
        }

        /**
         *
         * @param {Function} func - Function to trigger when readyState changes to complete
         * @param  {...any} funcArgs - Arguments to pass to function
         * @returns {Promise} Asynchronous wrapped function
         */
        static ready( func, ...funcArgs ) {
            return new Promise( ( resolve, reject ) => {
                Wait.set( 'complete', { resolve, reject, func, args: funcArgs } );
            } );
        }

        /**
         *
         * @param {Function} func - Function to trigger when window.load event is fired
         * @param  {...any} funcArgs - Arguments to pass to function
         * @returns {Promise} Asynchronous wrapped function
         */
        static load( func, ...funcArgs ) {
            return new Promise( ( resolve, reject ) => {
                Wait.set( 'complete', { resolve, reject, func, args: funcArgs } );
            } );
        }

    }

    class ImageLoader {

        constructor() {
            this.worker = new ExtendedWorker(
                () => {
                    self.onmessage = function onmessage( event ) {
                        url( event.data.data.url, event.data.id ).then(
                            ( [ id, result ] ) => {
                                self.postMessage( {
                                    id,
                                    data: { url: result || '' }
                                } );
                            }
                        );
                    };
                    function url( url, id, options ) {
                        options = !!options && typeof options === 'object' ? options : Object.create( null );
                        return new Promise( async ( resolve, reject ) => {
                            fetch( url, {
                                method: 'GET',
                                mode: 'cors',
                                credentials: 'include',
                                cache: 'default',
                                ...options
                            } ).then( async response => {
                                if ( response.status === 200 ) {
                                    try {
                                        const blob = await response.blob();
                                        return resolve( [ id, URL.createObjectURL( blob ) ] );
                                    }
                                    catch ( _ ) {
                                        console.error( _ );
                                        return reject( [ id, '' ] );
                                    }
                                }
                                console.error( response );
                                return reject( [ id, '' ] );
                            } )
                                .catch( _ => {
                                    console.error( _ );
                                    return reject( [ id, '' ] );
                                } );
                        } );
                    }
                },
                { promise: true }
            );
        }

        async load( options = {} ) {
            const { src, webp } = options;
            let res;
            if ( !!webp && typeof webp === 'string' ) {
                const _ = await WebPTest.passed;
                if ( _ ) {
                    res = ( await this.worker.postMessage( { url: webp } ) ).url;
                }
                else {
                    res = ( await this.worker.postMessage( { url: src } ) ).url;
                }
            }
            else {
                res = ( await this.worker.postMessage( { url: src } ) ).url;
            }
            return res;
        }

        static async load( options ) {
            const gl = getGlobal$1();
            if ( !( 'ImageLoader' in gl ) ) {
                gl.ImageLoader = new ImageLoader();
            }
            return await gl.ImageLoader.load( options );
        }

        terminate() {
            this.worker.terminate();
        }

        static terminate() {
            const gl = getGlobal$1();
            if ( 'ImageLoader' in gl ) {
                gl.ImageLoader.terminate();
                delete gl.ImageLoader;
            }
        }

    }

    var loading = { ImageLoader, Wait };

    /* eslint-env module */

    /**
     * Set of timing functions
     */
    const Easing = {
        /**
         * Linear
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        linearTween( t, b, c, d ) {
            return c * t / d + b;
        },
        /**
         * Quadratic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInQuad( t, b, c, d ) {
            t /= d;
            return c * t * t + b;
        },
        /**
         * Quadratic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeOutQuad( t, b, c, d ) {
            t /= d;
            return -c * t * ( t - 2 ) + b;
        },
        /**
         * Quadratic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInOutQuad( t, b, c, d ) {
            t /= d / 2;
            if ( t < 1 ) {
                return c / 2 * t * t + b;
            }
            t--;
            return -c / 2 * ( t * ( t - 2 ) - 1 ) + b;
        },
        /**
         * Cubic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInCubic( t, b, c, d ) {
            t /= d;
            return c * t * t * t + b;
        },
        /**
         * Cubic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeOutCubic( t, b, c, d ) {
            t /= d;
            t--;
            return c * ( t * t * t + 1 ) + b;
        },
        /**
         * Cubic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInOutCubic( t, b, c, d ) {
            t /= d / 2;
            if ( t < 1 ) {
                return c / 2 * t * t * t + b;
            }
            t -= 2;
            return c / 2 * ( t * t * t + 2 ) + b;
        },
        /**
         * Quartic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInQuart( t, b, c, d ) {
            t /= d;
            return c * t * t * t * t + b;
        },
        /**
         * Quartic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeOutQuart( t, b, c, d ) {
            t /= d;
            t--;
            return -c * ( t * t * t * t - 1 ) + b;
        },
        /**
         * Quartic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInOutQuart( t, b, c, d ) {
            t /= d / 2;
            if ( t < 1 ) {
                return c / 2 * t * t * t * t + b;
            }
            t -= 2;
            return -c / 2 * ( t * t * t * t - 2 ) + b;
        },
        /**
         * Quintic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInQuint( t, b, c, d ) {
            t /= d;
            return c * t * t * t * t * t + b;
        },
        /**
         * Quintic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeOutQuint( t, b, c, d ) {
            t /= d;
            t--;
            return c * ( t * t * t * t * t + 1 ) + b;
        },
        /**
         * Quintic
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInOutQuint( t, b, c, d ) {
            t /= d / 2;
            if ( t < 1 ) {
                return c / 2 * t * t * t * t * t + b;
            }
            t -= 2;
            return c / 2 * ( t * t * t * t * t + 2 ) + b;
        },
        /**
         * Sinusoidal
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInSine( t, b, c, d ) {
            return -c * Math.cos( t / d * ( Math.PI / 2 ) ) + c + b;
        },
        /**
         * Sinusoidal
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeOutSine( t, b, c, d ) {
            return c * Math.sin( t / d * ( Math.PI / 2 ) ) + b;
        },
        /**
         * Sinusoidal
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInOutSine( t, b, c, d ) {
            return -c / 2 * ( Math.cos( Math.PI * t / d ) - 1 ) + b;
        },
        /**
         * Exponential
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInExpo( t, b, c, d ) {
            return c * 2 ** ( 10 * ( t / d - 1 ) ) + b;
        },
        /**
         * Exponential
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeOutExpo( t, b, c, d ) {
            return c * ( -( 2 ** ( -10 * t / d ) ) + 1 ) + b;
        },
        /**
         * Exponential
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInOutExpo( t, b, c, d ) {
            t /= d / 2;
            if ( t < 1 ) {
                return c / 2 * 2 ** ( 10 * ( t - 1 ) ) + b;
            }
            t--;
            return c / 2 * ( -( 2 ** ( -10 * t ) ) + 2 ) + b;
        },
        /**
         * Circular
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInCirc( t, b, c, d ) {
            t /= d;
            return -c * ( Math.sqrt( 1 - t * t ) - 1 ) + b;
        },
        /**
         * Circular
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number}
         */
        easeOutCirc( t, b, c, d ) {
            t /= d;
            t--;
            return c * Math.sqrt( 1 - t * t ) + b;
        },
        /**
         * Circular
         * @param {Number} t - Current time
         * @param {Number} b - Start value
         * @param {Number} c - Change in value
         * @param {Number} d - Duration
         * @returns {Number} - Current value
         */
        easeInOutCirc( t, b, c, d ) {
            t /= d / 2;
            if ( t < 1 ) {
                return -c / 2 * ( Math.sqrt( 1 - t * t ) - 1 ) + b;
            }
            t -= 2;
            return c / 2 * ( Math.sqrt( 1 - t * t ) + 1 ) + b;
        }
    };

    /**
     * @typedef {Object} BigMathNumber
     * @property {BigInt} integer - Integer part
     * @property {Number[]} decimal - Decimal part
     */

    /**
     * @param {Number|BigInt} dividend - The dividend
     * @param {Number|BigInt} divisor - The divisor
     * @param {Number} accuracy - The accuracy of the result
     * @returns {BigMathNumber}
     */
    function div( dividend, divisor, accuracy = 100 ) {

        function addDigit( bigFloat, digit ) {
            if ( bigFloat.decimal[last].length === 1000 ) {
                bigFloat.decimal.push( [] );
                last += 1;
            }
            bigFloat.decimal[last].push( digit );
            accuracy -= 1;
        }

        const BigIntDividend = BigInt( dividend );
        const BigIntDivisor = BigInt( divisor );

        if ( BigIntDivisor === 0n ) {
            return Infinity;
        }

        const BigIntQuotient = BigIntDividend / BigIntDivisor;
        const BigIntRemainder = BigIntDividend - BigIntDivisor * BigIntQuotient;

        let last = 0;

        const BigFloat = { integer: 0n, decimal: [ [] ] };

        BigFloat.integer = BigIntQuotient;

        Object.defineProperty( BigFloat, 'toString', {
            value: function toString() {
                if ( this.decimal.length > 0 ) {
                    return `${ this.integer }.${ this.decimal.map( r => Array.isArray( r ) ? r.join( '' ) : r ).join( '' ) }`.replace( /n/gu, '' );
                }
                return `${ this.integer }`;
            }
        } );

        if ( BigIntRemainder === 0n ) {
            return BigFloat;
        }

        let r = BigIntRemainder * 10n;

        while ( accuracy > 0 ) {

            if ( r === 0n ) {
                break;
            }

            const quotient = r / BigIntDivisor;
            const remainder = r - quotient * BigIntDivisor;

            addDigit( BigFloat, Number( quotient ) );

            if ( remainder > 0 ) {
                r = remainder;
            }
            else {
                addDigit( BigFloat, Number( quotient ) );
                break;
            }

            if ( r < BigIntDivisor ) {
                r *= 10n;
            }
        }
        return BigFloat;
    }

    /**
     * @param {Number|BigInt} number
     * @param {Number|BigInt} factor
     * @returns {BigInt}
     */
    function mul( number, factor ) {
        return BigInt( number ) * BigInt( factor );
    }

    /**
     * @param {Number} target
     * @returns {BigInt}
     */
    function fact( target ) {
        let n = BigInt( target );
        if ( n < 0n ) {
            throw new Error();
        }
        let r = 1n;
        for ( ; n > 0n; n -= 1n ) {
            r *= n;
        }
        return r;
    }

    /**
     * @param {Number|BigInt} number
     * @param {Number} exp
     * @returns {BigInt}
     */
    function pow( number, exp ) {
        return BigInt( number ) ** BigInt( exp );
    }

    /**
     * @param {Number} number
     * @returns {BigInt}
     */
    function fib( index ) {
        let n0 = 0n;
        let n1 = 1n;
        for ( let nx = 2; nx <= index; nx += 1 ) {
            [ n0, n1 ] = [ n1, n0 + n1 ];
        }
        return n0;
    }

    var math = { Easing, div, mul, pow, fact, fib };

    /* eslint-env module */

    /**
     * Apply a smooth scroll animation when navigating through a page
     *
     * #browser-only
     *
     * @param {Event} event - The event object
     * @param {String} selector - CSS selector of the element to scroll to
     * @param {Number} duration - Duration of the animation in milliseconds
     */
    function smoothScrollTo( event, selector, duration = 1000 ) {
        event.preventDefault();
        event.stopPropagation();
        const { easeInOutCubic } = Easing;
        const target = document.querySelector( selector );
        if ( !( target instanceof HTMLElement ) ) {
            return;
        }
        const startPosition = window.pageYOffset;
        const targetPosition = startPosition + target.getBoundingClientRect().top;
        const distance = targetPosition - startPosition;
        let startTime = 0;

        /**
         * @param {Number} currentTime
         */
        function animation( currentTime ) {
            startTime = startTime ? startTime : currentTime;
            const timeElapsed = currentTime - startTime;
            const run = easeInOutCubic( timeElapsed, startPosition, distance, duration );
            window.scrollTo( 0, run );
            if ( timeElapsed < duration ) {
                window.requestAnimationFrame( animation );
            }
        }

        window.requestAnimationFrame( animation );
    }

    var move = { smoothScrollTo };

    /* eslint-env module */
    /**
     * Benchmark JavaScript Code
     */
    class Benchmark {

        /**
         * @param {{logging:Boolean}} [options] - Options passed to Benchmark
         */
        constructor( options = {} ) {
            this.perf = getGlobal$1().performance;
            this.options = {
                _logging: options.logging || false,
                _iterations: undefined,
                _last: undefined
            };
            this.match = {};
            this.metrics = new Map();
            this.pool = new Map();
            this.testPool = new Map();
            this.ticks = [];
        }

        /**
         * @returns {String}
         */
        static get uid() {
            return newUID( 10 );
        }

        /**
         * @returns {String}
         */
        set last( value ) {
            this.options._last = value;
        }

        /**
         * @returns {String}
         */
        get last() {
            return this.options._last;
        }

        /**
         * @returns {Boolean}
         */
        get logging() {
            return this.options._logging;
        }

        /**
         * @returns {Number|undefined}
         */
        get iterations() {
            return this.options._iterations;
        }

        /**
         * @param {Number} value
         * @returns {void}
         */
        set iterations( value ) {
            this.options._iterations = value;
        }

        /**
         *
         * @param {String} label
         * @param {Function} func
         * @param  {...any} args
         * @returns {Benchmark}
         */
        add( label, func, ...args ) {
            const { uid } = Benchmark;
            this.last = uid;
            this.match[uid] = label;
            this.pool.set( uid, () => {
                let end;
                let elapsed = 0;
                let i = 0;
                const test = this.testPool.get( uid );
                let start;
                if ( test ) {
                    do {
                        start = this.perf.now();
                        const result = func( ...args );
                        elapsed += this.perf.now() - start;
                        if ( !test( result ) ) {
                            console.group( `Test Failed - ${ label }` );
                            console.error( 'Test Function', test );
                            console.error( 'Tested Result', result );
                            console.groupEnd( `Test Failed - ${ label }` );
                            throw new Error( 'Test failed.' );
                        }
                    } while ( ( i++, elapsed < 5000 ) );
                }
                else {
                    start = this.perf.now();
                    do {
                        func( ...args );
                    } while ( ( i++, end = this.perf.now() ) < start + 5000 );
                    elapsed = end - start;
                }
                const ops = i / ( elapsed / 1000 );
                const result = { ops, elapsed, iterations: i };
                console.log( `Func ${ label }\n\t> ${ ops.toFixed( 3 ) } op/s\n\t> ${ i } op` );
                this.metrics.set( uid, result );
                return result;
            } );
            return this;
        }

        /**
         * @callback callback
         * @param {any} result
         * @returns {Boolean}
         */
        /**
         * @param {callback} func
         */
        test( func ) {
            const { last: uid } = this;
            this.testPool.set( uid, func );
            this.last = undefined;
            return this;
        }

        /**
         * @returns {void}
         */
        start() {
            const now = this.perf.now();
            if ( this.logging ) {
                console.warn( `Started ${ now } ms after page load.` );
            }
            this.ticks.push( now );
        }

        /**
         * @returns {Number}
         */
        tick() {
            const now = this.perf.now();
            const elapsed = now - this.ticks[this.ticks.length - 1];
            if ( this.logging ) {
                console.log( `Lap : ${ elapsed } ms` );
            }
            this.ticks.push( now );
            return elapsed;
        }

        /**
         * @returns {Number}
         */
        stop() {
            const now = this.perf.now();
            const lastLap = now - this.ticks[this.ticks.length - 1];
            const elapsed = now - this.ticks[0];
            if ( this.logging ) {
                if ( lastLap !== elapsed ) {
                    console.log( `Lap : ${ lastLap } ms` );
                }
                console.log( `Total : ${ elapsed } ms` );
                console.warn( `Ended ${ now } ms after page load.` );
            }
            this.ticks.push( now );
            return elapsed;
        }

        /**
         * @returns {Benchmark}
         */
        run() {
            const keys = [ ...this.pool.keys() ];
            const values = [ ...this.pool.values() ];
            console.group( 'Execution' );
            const results = values.map( func => func() );
            console.groupEnd();
            const sortMap = results.map( ( { ops }, index ) => [ keys[index], ops ] ).sort( ( [ $0, a ], [ $1, b ] ) => b - a );
            console.group( 'Results' );
            sortMap.forEach( ( [ key, ops ], index ) => {
                console.log( `#${ index + 1 } -- Func ${ this.match[key] }\n\t> ${ ops.toFixed( 3 ) } op/s` );
            } );
            console.groupEnd();
            return this;
        }

    }

    var perf = { Benchmark };

    exports.Content = content;
    exports.DOM = dom;
    exports.Dataset = dataset;
    exports.Functional = functional;
    exports.Loading = loading;
    exports.Math = math;
    exports.Move = move;
    exports.MultiThread = multithread;
    exports.Navigator = navigator;
    exports.Performance = perf;
    exports.Utils = utils;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});

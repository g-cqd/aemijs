"use strict";class e{static get scriptHandler(){return`()=>((globalThis||self||window)._=new (${PromiseHandler.toString()})());`}static get moduleHandler(){return`(globalThis||self||window)._=new (${PromiseHandler.toString()})();`}static importLocalScripts(e={}){const r=[];if("localImports"in e){const{localImports:s}=e;if("string"==typeof s)r.push(`${window.location.origin}/${t(s)}`);else{if(!Array.isArray(r))throw new Error("WorkerOptions.localImports is not correctly defined.");r.push(...r.map((e=>`${window.location.origin}/${t(e)}`)))}}return r}static importScripts(e={}){const r=[];if("importScripts"in e){const{importScripts:t}=e;if("string"==typeof t)r.push(t);else{if(!Array.isArray(t))throw new Error("WorkerOptions.importScripts is not correctly defined.");r.push(...t)}}return r}static importModuleLocalScripts(s={}){const o=[];if("localImports"in s){const{localImports:e}=s;if("string"==typeof e)o.push(`import ${r(e)} from '${window.location.origin}/${e}';`);else{if(!Array.isArray(e))throw new Error("WorkerOptions.localImports is not correctly defined.");for(const s of e)if("string"==typeof s)o.push(`import ${r(s)} from '${window.location.origin}/${t(s)}';`);else if("object"==typeof s){if(!("objects"in s||"*"in s||"name"in s)||!("path"in s))throw new Error("WorkerOptions.importScripts is not correctly defined.");const{objects:e,"*":r,name:i,path:n}=s;if(i)o.push(`import ${i} from '${window.location.origin}/${t(n)}';`);else if(r)o.push(`import ${e?"string"==typeof e?`{ ${e} },`:`{ ${e.join(",")} }, `:""}* as ${r} from '${window.location.origin}/${t(n)}';`);else{if(!e)throw new Error("WorkerOptions.importScripts is not correctly defined.");o.push(`import ${e?"string"==typeof e?`{ ${e} },`:`{ ${e.join(",")} } `:""} from '${window.location.origin}/${t(n)}';`)}}}}return"includeHandler"in s&&!0===s.includeHandler&&o.push(e.moduleHandler),o}static importModuleScripts(e={}){const t=[];if("importScripts"in e){const{importScripts:s}=e;if("string"==typeof s)t.push(`import ${r(s)} from '${s}';`);else{if(!Array.isArray(s))throw new Error("WorkerOptions.importScripts is not correctly defined.");for(const e of s)if("string"==typeof e)t.push(`import ${r(e)} from '${e}';`);else if("object"==typeof e){if(!("objects"in e||"*"in e||"name"in e)||!("path"in e))throw new Error("WorkerOptions.importScripts is not correctly defined.");const{objects:r,"*":s,name:o,path:i}=e;if(o)t.push(`import ${o} from '${i}';`);else if(s)t.push(`import ${r?"string"==typeof r?`{ ${r} },`:`{ ${r.join(",")} }, `:""}* as ${s} from '${i}';`);else{if(!r)throw new Error("WorkerOptions.importScripts is not correctly defined.");t.push(`import ${r?"string"==typeof r?`{ ${r} },`:`{ ${r.join(",")} } `:""} from '${i}';`)}}}}return t}static getHandlerAsURL(){return e.toObjectURL(`(${e.scriptHandler})();`)}static uglifyScriptWorker(r){if("string"==typeof r)return e.toObjectURL(r);throw new Error("WorkerString is not a string.")}static prepareForScriptImport(r,t={}){if("string"!=typeof r)throw new Error("WorkerString is not a string.");const s=[...e.importLocalScripts(t),...e.importScripts(t)];let o;return"includeHandler"in t&&!0===t.includeHandler&&s.push(e.getHandlerAsURL()),"uglify"in t&&!0===t.uglify?(s.push(e.uglifyScriptWorker(r)),o=`importScripts("${s.join('","')}");`):o=`${s.length>0?`importScripts("${s.join('","')}");\n`:""}(${r})();`,e.toObjectURL(o)}static prepareForModuleImport(r,t={}){if("string"!=typeof r)throw new Error("WorkerString is not a string.");const s=[...e.importModuleLocalScripts(t),...e.importModuleScripts(t)];let o;if("uglify"in t&&!0===t.uglify)throw new Error("WorkerOptions.uglify can not be applied to module worker.");return o=`${s.length>0?`${s.join("\n")}\n`:""}(${r})();`,e.toObjectURL(o)}static toObjectURL(e){return URL.createObjectURL(new Blob([e],{type:"application/javascript"}))}static createObjectURL(r,t={}){if("object"==typeof t){if("type"in t&&"module"===t.type)return e.prepareForModuleImport(r,t);if("type"in t&&"module"!==t.type&&"classic"!==t.type)throw new Error(`WorkerOptions.type:${t.type} is not a valid type.`);return e.prepareForScriptImport(r,t)}if("string"==typeof r)return e.toObjectURL(r);throw new Error("WorkerString is not a string.")}}function r(e){return e.split(/\//gu).pop().split(/\./gu).filter((e=>e.length>0)).shift()}function t(e){return`${e.replace(/^\/*/gu,"")}`}export class PromiseHandler{static#e=class{#r=Object.assign(Object.create(null),{resolves:Object.create(null),rejects:Object.create(null),listeners:Object.create(null)});constructor(){this.addListener("default",(e=>e)),globalThis.addEventListener("message",(e=>this.listen(e))),globalThis.addEventListener("messageerror",(e=>this.listen(e))),Object.freeze(this.#r)}get listeners(){return this.#r.listeners}listen(e){const{id:r,data:t,err:s}=e.data;if(r in this.#r.resolves||r in this.#r.rejects){const e=this.#r.resolves[r],o=this.#r.rejects[r];!s&&e?e(t):o&&s&&o(s),delete this.#r.resolves[r],delete this.#r.rejects[r]}else"object"==typeof t&&"type"in t&&t.type in this.listeners?this.listeners[t.type](r,t,e):this.listeners.default(r,t,e)}addListener(e,r,t={}){const{keepEvent:s,accessor:o}=t;this.listeners[e]=(e,t,i)=>{const n=o?t[o]:t,c=r(...s?[i,n]:[n]);c instanceof Promise?(c.then((r=>globalThis.postMessage({id:e,data:r}))),c.catch(console.error)):globalThis.postMessage({id:e,data:c})}}postMessage(e,r){const t=globalThis.crypto.randomUUID(),s=Object.assign(Object.create(null),{id:t,data:e});return new Promise(((e,o)=>{this.#r.resolves[t]=e,this.#r.rejects[t]=o,r?self.postMessage(s,r):self.postMessage(s)}))}};static#t={get:(e,r)=>r in e?e[r]:r.startsWith("__")?t=>e.postMessage({type:r.slice(2),data:t}):(t,s)=>e.addListener(r,t,s||{accessor:"data"})};constructor(){return globalThis._=new Proxy(new PromiseHandler.#e,PromiseHandler.#t)}}export class ExtendedWorkerProxy{static#t={get:(e,r)=>r in e?e[r]:r.startsWith("__")?t=>e.addEventListener("message",(({data:s})=>{const{data:o,id:i}=s,{type:n,data:c}=o;if(n===r.slice(2)){const r=t(c);Worker.prototype.postMessage.call(e,{id:i,data:r})}})):(t,s)=>e.postMessage({type:r,data:t},s)};constructor(e,r){return e instanceof ExtendedWorker?new Proxy(e,ExtendedWorkerProxy.#t):new Proxy(new ExtendedWorker(e,r),ExtendedWorkerProxy.#t)}}export class ClusterProxy{static parsePropertyDecorator(e){if("string"==typeof e){const{groups:r}=e.match(/^(?<race>\$)?(?<spread>_)?/u),t=Boolean(r.race),s=Boolean(r.spread);return{modes:{race:t,spread:s},property:e.slice(t+s)}}return e}static#t={get:(e,r)=>{if(r in e)return e[r];const{modes:t,property:s}=ClusterProxy.parsePropertyDecorator(r);return(r,o)=>e.postMessage({type:s},void 0,{modes:t,data:r,transferable:o})}};constructor(e,r){return e instanceof Cluster?new Proxy(e,ClusterProxy.#t):new Proxy(new Cluster(e,r),ClusterProxy.#t)}}export class ExtendedWorker extends Worker{static new(e,r={}){return new ExtendedWorkerProxy(e,{promise:!0,type:"module",includeHandler:!0,...r})}static async run(e,r,t){const s=new FunctionWorker(e),o=await s.run(r,t);return s.terminate(),o}#r={resolves:Object.create(null),rejects:Object.create(null),promise:!1};constructor(r,t){let s;if("function"==typeof r)s=e.createObjectURL(r.toString(),t);else{if("string"!=typeof r)throw new Error("WorkerObject is not a string or a function.");s=e.createObjectURL(r,t)}if(super(s,t),this.#r.promise=t&&t.promise){const e=e=>{if(this.#r.promise){const{id:r,err:t,data:s}=e.data;if(r in this.#r.resolves||r in this.#r.rejects){const e=this.#r.resolves[r],o=this.#r.rejects[r];!t&&e?e(s):o&&t&&o(t),delete this.#r.resolves[r],delete this.#r.rejects[r]}}};this.addEventListener("message",e),this.addEventListener("messageerror",e)}Object.freeze(this.#r)}postMessage(e,r){const t=globalThis.crypto.randomUUID();if(this.#r.promise){const s=Object.assign(Object.create(null),{id:t,data:e});return new Promise(((e,o)=>{this.#r.resolves[t]=e,this.#r.rejects[t]=o,r?super.postMessage(s,r):super.postMessage(s)}))}super.postMessage(e,r)}}export class Cluster{static#s=4;static set DEFAULT_SIZE(e){this.#s=e}static get DEFAULT_SIZE(){return this.#s}static async run(e,r,t){const s=new FunctionCluster(e),o=await s.run(r,t);return s.terminate(),o}static async $run(e,r,t){const s=new FunctionCluster(e),o=await s.$run(r,t);return s.terminate(),o}static async _run(e,r,t){const s=new FunctionCluster(e),o=await s._run(r,t);return s.terminate(),o}static async $_run(e,r,t){const s=new FunctionCluster(e),o=await s.$_run(r,t);return s.terminate(),o}static new(e,r={}){return new ClusterProxy(e,{promise:!0,type:"module",includeHandler:!0,size:Cluster.DEFAULT_SIZE,...r})}#r={size:Cluster.DEFAULT_SIZE,workers:void 0};constructor(e,r){const t=(r?r.size:Cluster.DEFAULT_SIZE)||Cluster.DEFAULT_SIZE;this.#r.workers=Array(t),this.#r.size=t;for(let t=0;t<this.#r.size;t++)this.#r.workers[t]=new ExtendedWorker(e,r);Object.freeze(this.#r.workers),Object.freeze(this.#r)}dispatchEvent(e){return Promise.all(this.#r.workers.map((r=>r.dispatchEvent(e))))}addEventListener(e,r,t){return Promise.all(this.#r.workers.map((s=>s.addEventListener(e,r,t))))}removeEventListener(e,r,t){return Promise.all(this.#r.workers.map((s=>s.removeEventListener(e,r,t))))}postMessage(e,r,{modes:{race:t,spread:s}={},data:o,transferable:i}={}){if(void 0!==t||void 0!==s)switch(!0){case t&&s:return Promise.race(this.#r.workers.map(((r,t)=>r.postMessage({...e,data:o[t]},i?i[t]:null))));case t:return Promise.race(this.#r.workers.map((r=>r.postMessage({...e,data:o},i))));case s:return Promise.all(this.#r.workers.map(((r,t)=>r.postMessage({...e,data:o[t]},i?i[t]:null))));default:return Promise.all(this.#r.workers.map((r=>r.postMessage({...e,data:o},i))))}return Promise.all(this.#r.workers.map((t=>t.postMessage(e,r))))}terminate(){for(const e of this.#r.workers)e.terminate()}}export class FunctionWorker extends ExtendedWorkerProxy{constructor(e,r){super(`async()=>_.proxy_run(${e.toString()})`,{promise:!0,type:"module",includeHandler:!0,...r})}run(...e){return super.proxy_run(...e)}}export class FunctionCluster extends ClusterProxy{constructor(e,r){super(`async()=>_.proxy_run(${e})`,{size:Cluster.DEFAULT_SIZE,...r})}run(...e){return super.proxy_run(...e)}$run(...e){return super.$proxy_run(...e)}_run(...e){return super._proxy_run(...e)}$_run(...e){return super.$_proxy_run(...e)}}export default{Cluster,ClusterProxy,ExtendedWorker,ExtendedWorkerProxy,FunctionCluster,FunctionWorker,PromiseHandler};
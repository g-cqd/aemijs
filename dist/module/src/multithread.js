"use strict";class r{static get scriptHandler(){return`()=>((globalThis||self||window)._=new (${PromiseHandler.toString()})());`}static get moduleHandler(){return`(globalThis||self||window)._=new (${PromiseHandler.toString()})();`}static importLocalScripts(r={}){const e=[];if("localImports"in r){const{localImports:o}=r;if("string"==typeof o)e.push(`${window.location.origin}/${t(o)}`);else{if(!Array.isArray(e))throw new Error("WorkerOptions.localImports is not correctly defined.");e.push(...e.map((r=>`${window.location.origin}/${t(r)}`)))}}return e}static importScripts(r={}){const e=[];if("importScripts"in r){const{importScripts:t}=r;if("string"==typeof t)e.push(t);else{if(!Array.isArray(t))throw new Error("WorkerOptions.importScripts is not correctly defined.");e.push(...t)}}return e}static importModuleLocalScripts(o={}){const s=[];if("localImports"in o){const{localImports:r}=o;if("string"==typeof r)s.push(`import ${e(r)} from '${window.location.origin}/${r}';`);else{if(!Array.isArray(r))throw new Error("WorkerOptions.localImports is not correctly defined.");for(const o of r)if("string"==typeof o)s.push(`import ${e(o)} from '${window.location.origin}/${t(o)}';`);else if("object"==typeof o){if(!("objects"in o||"*"in o||"name"in o)||!("path"in o))throw new Error("WorkerOptions.importScripts is not correctly defined.");const{objects:r,"*":e,name:n,path:i}=o;if(n)s.push(`import ${n} from '${window.location.origin}/${t(i)}';`);else if(e)s.push(`import ${r?"string"==typeof r?`{ ${r} },`:`{ ${r.join(",")} }, `:""}* as ${e} from '${window.location.origin}/${t(i)}';`);else{if(!r)throw new Error("WorkerOptions.importScripts is not correctly defined.");s.push(`import ${r?"string"==typeof r?`{ ${r} },`:`{ ${r.join(",")} } `:""} from '${window.location.origin}/${t(i)}';`)}}}}return"includeHandler"in o&&!0===o.includeHandler&&s.push(r.moduleHandler),s}static importModuleScripts(r={}){const t=[];if("importScripts"in r){const{importScripts:o}=r;if("string"==typeof o)t.push(`import ${e(o)} from '${o}';`);else{if(!Array.isArray(o))throw new Error("WorkerOptions.importScripts is not correctly defined.");for(const r of o)if("string"==typeof r)t.push(`import ${e(r)} from '${r}';`);else if("object"==typeof r){if(!("objects"in r||"*"in r||"name"in r)||!("path"in r))throw new Error("WorkerOptions.importScripts is not correctly defined.");const{objects:e,"*":o,name:s,path:n}=r;if(s)t.push(`import ${s} from '${n}';`);else if(o)t.push(`import ${e?"string"==typeof e?`{ ${e} },`:`{ ${e.join(",")} }, `:""}* as ${o} from '${n}';`);else{if(!e)throw new Error("WorkerOptions.importScripts is not correctly defined.");t.push(`import ${e?"string"==typeof e?`{ ${e} },`:`{ ${e.join(",")} } `:""} from '${n}';`)}}}}return t}static getHandlerAsURL(){return r.toObjectURL(`(${r.scriptHandler})();`)}static uglifyScriptWorker(e){if("string"==typeof e)return r.toObjectURL(e);throw new Error("WorkerString is not a string.")}static prepareForScriptImport(e,t={}){if("string"!=typeof e)throw new Error("WorkerString is not a string.");const o=[...r.importLocalScripts(t),...r.importScripts(t)];let s;return"includeHandler"in t&&!0===t.includeHandler&&o.push(r.getHandlerAsURL()),"uglify"in t&&!0===t.uglify?(o.push(r.uglifyScriptWorker(e)),s=`importScripts("${o.join('","')}");`):s=`${o.length>0?`importScripts("${o.join('","')}");\n`:""}(${e})();`,r.toObjectURL(s)}static prepareForModuleImport(e,t={}){if("string"!=typeof e)throw new Error("WorkerString is not a string.");const o=[...r.importModuleLocalScripts(t),...r.importModuleScripts(t)];let s;if("uglify"in t&&!0===t.uglify)throw new Error("WorkerOptions.uglify can not be applied to module worker.");return s=`${o.length>0?`${o.join("\n")}\n`:""}(${e})();`,r.toObjectURL(s)}static toObjectURL(r){return URL.createObjectURL(new Blob([r],{type:"application/javascript"}))}static createObjectURL(e,t={}){if("object"==typeof t){if("type"in t&&"module"===t.type)return r.prepareForModuleImport(e,t);if("type"in t&&"module"!==t.type&&"classic"!==t.type)throw new Error(`WorkerOptions.type:${t.type} is not a valid type.`);return r.prepareForScriptImport(e,t)}if("string"==typeof e)return r.toObjectURL(e);throw new Error("WorkerString is not a string.")}}function e(r){return r.split(/\//gu).pop().split(/\./gu).filter((r=>r.length>0)).shift()}function t(r){return`${r.replace(/^\/*/gu,"")}`}export class PromiseHandler{static#r=class{#e=Object.assign(Object.create(null),{listeners:Object.create(null)});constructor(){this.addListener("default",(r=>r)),globalThis.addEventListener("message",(r=>this.listen(r))),globalThis.addEventListener("messageerror",(r=>this.listen(r))),Object.freeze(this.#e)}get listeners(){return this.#e.listeners}listen(r){const{id:e,data:t}=r.data;"object"==typeof t&&"type"in t&&t.type in this.listeners?this.listeners[t.type](e,t,r):this.listeners.default(e,t,r)}addListener(r,e,t={}){const{keepEvent:o,accessor:s}=t;this.listeners[r]=(r,t,n)=>{const i=s?t[s]:t,c=e(...o?[n,i]:[i]);c instanceof Promise?(c.then((e=>globalThis.postMessage({id:r,data:e}))),c.catch(console.error)):globalThis.postMessage({id:r,data:c})}}};static#t={get:(r,e)=>e in r?r[e]:(t,o)=>r.addListener(e,t,o||{accessor:"data"})};constructor(){return globalThis._=new Proxy(new PromiseHandler.#r,PromiseHandler.#t)}}export class ExtendedWorkerProxy{static#t={get:(r,e)=>e in r?r[e]:(t,o)=>r.postMessage({type:e,data:t},o)};constructor(r,e){return r instanceof ExtendedWorker?new Proxy(r,ExtendedWorkerProxy.#t):new Proxy(new ExtendedWorker(r,e),ExtendedWorkerProxy.#t)}}export class ClusterProxy{static parsePropertyDecorator(r){if("string"==typeof r){const{groups:e}=r.match(/^(?<race>\$)?(?<spread>_)?/u),t=Boolean(e.race),o=Boolean(e.spread);return{modes:{race:t,spread:o},property:r.slice(t+o)}}return r}static#t={get:(r,e)=>{if(e in r)return r[e];const{modes:t,property:o}=ClusterProxy.parsePropertyDecorator(e);return(e,s)=>r.postMessage({type:o},void 0,{modes:t,data:e,transferable:s})}};constructor(r,e){return r instanceof Cluster?new Proxy(r,ClusterProxy.#t):new Proxy(new Cluster(r,e),ClusterProxy.#t)}}export class ExtendedWorker extends Worker{static new(r,e={}){return new ExtendedWorkerProxy(r,{promise:!0,type:"module",includeHandler:!0,...e})}static async run(r,e,t){const o=new FunctionWorker(r),s=await o.run(e,t);return o.terminate(),s}#e={resolves:Object.create(null),rejects:Object.create(null),promise:!1};#o=0;constructor(e,t){let o;if("function"==typeof e)o=r.createObjectURL(e.toString(),t);else{if("string"!=typeof e)throw new Error("WorkerObject is not a string or a function.");o=r.createObjectURL(e,t)}if(super(o,t),this.#e.promise=t&&t.promise){const r=r=>{if(this.#e.promise){const{id:e,err:t,data:o}=r.data,s=this.#e.resolves[e],n=this.#e.rejects[e];!t&&s?s(o):n&&t&&n(t),delete this.#e.resolves[e],delete this.#e.rejects[e]}};this.addEventListener("message",r),this.addEventListener("messageerror",r)}Object.freeze(this.#e)}postMessage(r,e){const t=this.#o++;if(this.#e.promise){const o=Object.assign(Object.create(null),{id:t,data:r});return new Promise(((r,s)=>{this.#e.resolves[t]=r,this.#e.rejects[t]=s,e?super.postMessage(o,e):super.postMessage(o)}))}super.postMessage(r,e)}}export class Cluster{static#s=4;static set DEFAULT_SIZE(r){this.#s=r}static get DEFAULT_SIZE(){return this.#s}static async run(r,e,t){const o=new FunctionCluster(r),s=await o.run(e,t);return o.terminate(),s}static async $run(r,e,t){const o=new FunctionCluster(r),s=await o.$run(e,t);return o.terminate(),s}static async _run(r,e,t){const o=new FunctionCluster(r),s=await o._run(e,t);return o.terminate(),s}static async $_run(r,e,t){const o=new FunctionCluster(r),s=await o.$_run(e,t);return o.terminate(),s}static new(r,e={}){return new ClusterProxy(r,{promise:!0,type:"module",includeHandler:!0,size:Cluster.DEFAULT_SIZE,...e})}#e={size:Cluster.DEFAULT_SIZE,workers:void 0};constructor(r,e){const t=(e?e.size:Cluster.DEFAULT_SIZE)||Cluster.DEFAULT_SIZE;this.#e.workers=Array(t),this.#e.size=t;for(let t=0;t<this.#e.size;t++)this.#e.workers[t]=new ExtendedWorker(r,e);Object.freeze(this.#e.workers),Object.freeze(this.#e)}dispatchEvent(r){return Promise.all(this.#e.workers.map((e=>e.dispatchEvent(r))))}addEventListener(r,e,t){return Promise.all(this.#e.workers.map((o=>o.addEventListener(r,e,t))))}removeEventListener(r,e,t){return Promise.all(this.#e.workers.map((o=>o.removeEventListener(r,e,t))))}postMessage(r,e,{modes:{race:t,spread:o}={},data:s,transferable:n}={}){if(void 0!==t||void 0!==o)switch(!0){case t&&o:return Promise.race(this.#e.workers.map(((e,t)=>e.postMessage({...r,data:s[t]},n?n[t]:null))));case t:return Promise.race(this.#e.workers.map((e=>e.postMessage({...r,data:s},n))));case o:return Promise.all(this.#e.workers.map(((e,t)=>e.postMessage({...r,data:s[t]},n?n[t]:null))));default:return Promise.all(this.#e.workers.map((e=>e.postMessage({...r,data:s},n))))}return Promise.all(this.#e.workers.map((t=>t.postMessage(r,e))))}terminate(){for(const r of this.#e.workers)r.terminate()}}export class FunctionWorker extends ExtendedWorkerProxy{constructor(r,e){super(`async()=>_.proxy_run(${r.toString()})`,{promise:!0,type:"module",includeHandler:!0,...e})}run(...r){return super.proxy_run(...r)}}export class FunctionCluster extends ClusterProxy{constructor(r,e){super(`async()=>_.proxy_run(${r})`,{size:Cluster.DEFAULT_SIZE,...e})}run(...r){return super.proxy_run(...r)}$run(...r){return super.$proxy_run(...r)}_run(...r){return super._proxy_run(...r)}$_run(...r){return super.$_proxy_run(...r)}}export default{Cluster,ClusterProxy,ExtendedWorker,ExtendedWorkerProxy,FunctionCluster,FunctionWorker,PromiseHandler};
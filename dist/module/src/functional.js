export function pipe(...t){if(t.length>0)return t.reduce(((t,e)=>r=>e(t(r))));throw new Error("No function passed.")}export function compose(...t){if(t.length>0)return t.reduceRight(((t,e)=>r=>e(t(r))));throw new Error("No function passed.")}export class IArray{static toImmutable(t){if(IArray.isIArray(t))return Object.freeze(t);if(Array.isArray(t)||Symbol.iterator in t&&void 0!==t.length&&void 0!==t[0])return Object.freeze(Object.setPrototypeOf(t,IArray.prototype));throw new TypeError("Please use IArray.from")}static from(...t){switch(t.length){case 0:throw new Error("What's the point of creating an Immutable 0-sized ?");case 1:{const e=[],r=t[0];if(r&&Symbol.iterator in r){const t=r[Symbol.iterator]();let n,s;for(;({value:n,done:s}=t.next()),!s;)e.push(n)}else if(r&&"object"==typeof r)for(const t in r)Object.prototype.hasOwnProperty.call(r,t)&&e.push(r[t]);return IArray.toImmutable(e)}default:return new IArray(...t)}}static isIArray(t){return Object.getPrototypeOf(t)===IArray.prototype&&"length"in t&&"number"==typeof t.length&&(!Object.isExtensible(t)||Object.isFrozen(t))}static[Symbol.hasInstance](t){return IArray.isIArray(t)}static isCollapsable(t){return IArray.isIArray(t)||Array.isArray(t)}static isResizable(t){return Object.isExtensible(t)}static isImmutable(t){return Object.isFrozen(t)}constructor(...t){const{length:e}=t;if(1===e&&"number"==typeof t[0])this.length=t[0];else{this.length=e;for(let r=0;r<e;r+=1)this[r]=t[r];Object.freeze(this)}}[Symbol.iterator](){const{length:t}=this;let e=0;return{next:()=>({value:e<t?this[e]:void 0,done:e++>=t})}}toString(){const{length:t}=this;if(0===t)return"";let e=`${this[0]}`;for(let r=1;r<t;r+=1)e+=`,${this[r]}`;return e}deepLength(){const{length:t}=this;let e=t;for(let r=0;r<t;r+=1)IArray.isCollapsable(this[r])&&(e+=IArray.prototype.deepLength.call(this[r])-1);return e}initialize(){if(IArray.isImmutable(this))throw new Error("As an immutable data structure, <initialize> method can not be called on it.");for(let t=0,{length:e}=this;t<e;t+=1)this[t]=null;return Object.preventExtensions(this)}fill(t,e,r){if(IArray.isImmutable(this))throw new Error("As an immutable data structure, <fill> method can not be called on it.");{const{length:n}=this,s=void 0!==r&&r>=0&&r<n?r>e?r:e:n;for(let o=void 0!==e&&e>=0&&e<n?e<r?e:r:0;o<s;o+=1)this[o]=t;return Object.freeze(this)}}populate(t){if(IArray.isImmutable(this))throw new Error("As an immutable data structure, <populate> method can not be called on it.");for(let e=0,{length:r}=this;e<r;e+=1)this[e]=t(e,this);return Object.freeze(this)}at(t){return t<0?this[this.length+t]:t}values(){return{[Symbol.iterator]:this[Symbol.iterator]}}entries(){return{[Symbol.iterator]:()=>{const{length:t}=this;let e=0;return{next:()=>({value:e<t?new IArray(e,this[e]):void 0,done:e++>=t})}}}}keys(){return{[Symbol.iterator]:()=>{const{length:t}=this;let e=0;return{next:()=>({value:e<t?e:void 0,done:e++>=t})}}}}forEach(t,e){const r=e||this;for(let e=0,{length:n}=r;e<n;e+=1)t(r[e],e,r)}includes(t,e){for(let{length:r}=this,n=e>=0&&e<r?e:0;n<r;n+=1)if(Object.is(this[n],t))return!0;return!1}indexOf(t,e){for(let{length:r}=this,n=e>=0&&e<r?e:0;n<r;n+=1)if(Object.is(this[n],t))return n;return-1}lastIndexOf(t,e){for(let{length:r}=this,n=e>=0&&e<r?e:r;n>0;n-=1)if(Object.is(this[n],t))return n;return-1}map(t,e){const r=e||this;return new IArray(r.length).populate((e=>t(r[e],e,r)))}reduce(t,e){let r=e||this[0];for(let e=0,{length:n}=this;e<n;e+=1)r=t(r,this[e],e,this);return r}reduceRight(t,e){const{length:r}=this;let n=e||this[r-1];for(let e=r;e>0;e-=1)n=t(n,this[e],e,this);return n}filter(t,e){const r=e||this,{length:n}=r,s=new IArray(0);for(let e=0;e<n;e+=1)t(r[e],e,r)&&s.push(r[e]);return IArray.toImmutable(s)}every(t,e){const r=e||this;for(let e=0,{length:n}=r;e<n;e+=1)if(!t(r[e],e,r))return!1;return!0}some(t,e){const r=e||this,{length:n}=r;for(let e=0;e<n;e+=1)if(t(r[e],e,r))return!0;return!1}find(t,e){const r=e||this,{length:n}=r;for(let e=0;e<n;e+=1)if(t(r[e],e,r))return r[e]}findIndex(t,e){const r=e||this,{length:n}=r;for(let e=0;e<n;e+=1)if(t(r[e],e,r))return e;return-1}reverse(){const{length:t}=this,e=new IArray(t);for(let r=1;r<=t;r+=1)e[r-1]=this[t-r];return IArray.toImmutable(e)}slice(t,e){const{length:r}=this,n=t>=0&&t<r?t:0,s=e>=0&&e<=r?e:r,o=new IArray(s-n);let i=0;for(let t=n;t<s;t+=1)o[i++]=this[t];return IArray.toImmutable(o)}splice(t,e,...r){const{length:n}=this,{length:s}=r;let o=void 0===e?n-t:e>=0?e:0;const i=n-o+s;console.log(i);const l=new IArray(i);let h=0;for(let e=0;e<n;e+=1)if(e===t){if(s)for(let t=0;t<s;t+=1)l[h++]=r[t],(o-=1)>0&&(e+=1)}else if(e>t){for(;(o-=1)>0&&e<n;)e+=1;e<n&&(l[h++]=this[e])}else l[h++]=this[e];return IArray.toImmutable(l)}flatMap(t,e){const r=e||this,{length:n}=r,s=[];for(let e=0;e<n;e+=1){const n=t(r[e],e,r);if(IArray.isCollapsable(n))for(let t=0,{length:r}=n;e<r;e+=1)void 0!==n[t]&&s.push(n[_j]);else void 0!==n&&s.push(n)}return IArray.toImmutable(s)}flat(t){const e=[];for(let r=0,{length:n}=this;r<n;r+=1)if(t>1&&IArray.isCollapsable(this[r])){const n=this[r].flat(t-1);for(let t=0,{length:r}=n;t<r;t+=1)e.push(n[t])}else e.push(this[r]);return IArray.toImmutable(e)}concat(...t){const e=[];for(let t=0,{length:r}=this;t<r;t+=1)e.push(this[t]);for(let r=0,{length:n}=t;r<n;r+=1)if(IArray.isCollapsable(t[r]))for(let n=0,{length:s}=t[r];n<s;n+=1)e.push(t[n]);else e.push(t[r]);return IArray.toImmutable(e)}copyWithin(t,e,r){const{length:n}=this,s=new IArray(n);if(t>n){for(let t=0;t<n;t+=1)s[t]=this[t];return IArray.toImmutable(s)}const o=void 0===e?0:e<0?n+e:e>n?n:e,i=void 0===r?n:r<0?n+r:r>n?n:r;let l=0,[h,a]=o<i?[i-o,o]:[o-i,i];for(let e=0;e<n;e+=1)e>=t&&h-- >0?s[l]=this[a++]:s[l]=this[e],l+=1;return IArray.toImmutable(s)}join(t){const{length:e}=this;let r="";for(let n=0;n<e;n+=1)r+=`${t}${this[n]}`;return r}sort(t){const e=t||((t,e)=>t<e),{length:r}=this;if(r<=1)return IArray.from(this);const n=Math.floor(r/2),s=this.slice(0,n),o=this.slice(n);return function(t,r){const{length:n}=t,{length:s}=r,o=new IArray(n+s);let i=0,l=0,h=0;for(;l<n&&h<s;)e(t[l],r[h])?o[i++]=t[l++]:o[i++]=r[h++];for(let e=l;e<n;e+=1)o[i++]=t[e];for(let t=h;t<s;t+=1)o[i++]=r[t];return IArray.toImmutable(o)}(s.sort(t),o.sort(t))}reshape(...t){const{length:e}=t;if(0===e)return this.flat(1/0);let r=this.flat(1/0);const{length:n}=r;if(e>=1&&(n%t.reduce(((t,e)=>t*e))!=0||n%t[0]!=0))throw new RangeError(`An array of shape (${n}, 1)  can not be converted to an array of shape (${t.join(",")})`);for(let n=e-1;n>=0;n-=1){const e=t[n],s=r.length/e;r=new IArray(s).populate((t=>new IArray(e).populate((n=>r[t*e+n]))))}return r}push(...t){const{length:e}=this,{length:r}=t,n=e+r;if(IArray.isImmutable(this)){const s=new IArray(n);for(let t=0;t<e;t+=1)s[t]=this[t];for(let n=0;n<r;n+=1)s[n+e]=t[n];return Object.freeze(s)}if(IArray.isResizable(this)){for(let n=0;n<r;n+=1)this[e+n]=t[n];return this.length=n,this}throw new Error("What the fuck are you doing ?")}empty(){if(IArray.isImmutable(this))throw new TypeError("As an immutable data structure, <empty> method can not be called on it.");for(let t=0,{length:e}=this;t<e;t+=1)this[t]=null;return this}}export default{pipe,compose,IArray};
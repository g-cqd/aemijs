export class DatasetEncoder{constructor(){this.values=[]}getEncoded(e){const t=this.values.indexOf(e);return t>-1?t:(this.length=this.values.push(e),this.length-1)}getDecoded(e){if(this.length<=e)throw new Error;return this.values[e]}getOneHotEncoded(e){const t=this.values.indexOf(e);if(t>-1){const e=Array(this.values.length).fill(0);return e[t]=1,e}throw new Error}getOneHotEncodedByIndex(e){const{length:t}=this.values;if(e>=t||e<0)throw new Error;{const s=Array(t).fill(0);return s[e]=1,s}}}export class DatasetHeader{constructor(e,t){this.keys=new Map,this.types=new Map,this.indexes=new Map,this.encoders=new Map,this.nextIndex=0,e&&this.parseFromArray(e,t)}get columns(){return[...this.indexes.keys()]}getColumnByKey(e){if(this.indexes.has(e))return{key:e,index:this.indexes.get(e),...this.types.has(e)?{type:this.types.get(e)}:{},...this.encoders.has(e)?{encoder:this.encoders.get(e)}:{}}}getColumnByIndex(e){if(this.keys.has(e)){const t=this.keys.get(e);return{key:t,index:e,...this.types.has(t)?{type:this.types.get(t)}:{},...this.encoders.has(t)?{encoder:this.encoders.get(t)}:{}}}}getColumnKeyByColumnIndex(e){return this.keys.get(e)}getColumnIndexByColumnKey(e){return this.indexes.get(e)}registerColumnEncoderByColumnKey(e){const t=new DatasetEncoder(e);return this.encoders.set(e,t),t}getColumnEncoderByColumnKey(e){return this.encoders.get(e)}registerColumnEncoderByColumnIndex(e){const t=this.keys.get(e),s=new DatasetEncoder(t);return this.encoders.set(t,s),s}getColumnEncoderByColumnIndex(e){return this.encoders.get(this.keys.get(e))}getColumnTypeByColumnKey(e){return this.types.get(e)}setColumnTypeByColumnKey(e,t){this.types.set(e,Dataset.parseType(t))}getColumnTypeByColumnIndex(e){return this.types.get(this.keys.get(e))}setColumnTypeByColumnIndex(e,t){this.types.set(this.keys.get(e),Dataset.parseType(t))}hasColumn(e){return this.indexes.has(e)}doesIndexExist(e){return this.keys.has(e)}addColumn(e,t,s=!1){const n=this.nextIndex++;this.keys.set(n,e),this.indexes.set(e,n),this.types.set(e,Dataset.parseType(t)),s&&this.encoders.set(e,new DatasetEncoder(e))}removeColumns(e){const t=Array.isArray(e)?e:[e],s=[];for(const e of t){this.types.delete(e),this.encoders.delete(e);const t=this.indexes.get(e);this.keys.delete(t),this.indexes.delete(e),s.push(t)}const n=new Map,r=new Map;let o=0;for(const e of this.indexes.keys())n.set(e,o),r.set(o,e),o+=1;return this.indexes=n,this.keys=r,this.nextIndex=o,s}parseFromArray(e,t={}){const{types:s={},encoders:n=[]}=t;for(const t of e)this.addColumn(t,s[t],n.includes(t));this.nextIndex=e.length}static parseFromArray(e,t={}){const{types:s={},encoders:n=[]}=t,r=new DatasetHeader;for(const t of e)r.addColumn(t,s[t],n.includes(t));return r.nextIndex=e.length,r}}export class Dataset{static log(e,t=!0){if(console.log(`\n<-- ${e.length} ROWS --\x3e`),t)if(e.length>10){const t=e.slice(0,5),s=e.slice(-5);for(const e of t)Array.isArray(e[0])?console.log("[ ",e.map((e=>Array.isArray(e)?`\n  [ ${e.join(", ")} ]`:e)).join(", "),"\n]"):console.log("[ ",e.join(", ")," ]");for(let e=0;e<3;e+=1)console.log("...");for(const e of s)Array.isArray(e[0])?console.log("[ ",e.map((e=>Array.isArray(e)?`\n  [ ${e.join(", ")} ]`:e)).join(", "),"\n]"):console.log("[ ",e.join(", ")," ]")}else for(const t of e)Array.isArray(t[0])?console.log("[ ",t.map((e=>Array.isArray(e)?`\n  [ ${e.join(", ")} ]`:e)).join(", "),"\n]"):console.log("[ ",t.join(", ")," ]");else{const t=e.slice(0,5),s=e.slice(-5);for(const e of t)console.log(e);for(let e=0;e<3;e+=1)console.log("...");for(const e of s)console.log(e)}console.log(`<-- ${e.length} ROWS --\x3e\n`)}static _getLines(e){return e.split(/\n/gu)}static _getCells(e){return e.map((e=>e.replace(/\r/gu,"").split(/,/gu).map((e=>e.trim()))))}static _getNotEmptyLines(e){return e.filter((e=>e.length>0&&e.some((e=>!0==!!e))))}static readFile(e){let t;if(e instanceof ArrayBuffer){t=new TextDecoder("utf-8").decode(e)}return Dataset._getNotEmptyLines(Dataset._getCells(Dataset._getLines(t||e)))}static _flat(e,t,s={}){const{sortFunctionMap:n,filterFunctionMap:r,groupByFilterFunctionMap:o}=s,[i,...a]=e;if(void 0!==i){let e=t;if(e instanceof Map){if(e=[...t.keys()],n&&n.has(i)){let t;(t=n.get(i))&&(e=e.sort(t))}if(e=e.map((e=>Dataset._flat(a,t.get(e),{sortFunctionMap:n,filterFunctionMap:r,groupByFilterFunctionMap:o}))),o&&o.has(i)){let t;(t=o.get(i))&&(e=e.filter(t))}if(e=e.flat(1),r&&r.has(i)){let t;(t=r.get(i))&&(e=e.filter(t))}return e}if(Array.isArray(e)){if(r&&r.has(i)){let t;(t=r.get(i))&&(e=e.filter(t))}if(n&&n.has(i)){let t;(t=n.get(i))&&(e=e.sort(((e,s)=>t(e[i],s[i]))))}return e}return t}return t}static _groupBy(e,t){const[s,...n]=t;if(void 0!==s&&s>=0){const t=e.reduce(((e,t)=>{const n=t[s],r=e.has(n)?e.get(n):[];return r.push(t),e.set(n,r)}),new Map);if(n.length>0)for(const[e,s]of t.entries())t.set(e,Dataset._groupBy(s,n));return t}return e}static parseType(e){function t(e){return""===e?void 0:e}if("function"==typeof e)return function(t){return e(t)};switch(e){case"number":return function(e){const s=t(e);return void 0===s||Number.isNaN(+s)?NaN:+s};case"bigint":return function(e){return BigInt(t(e))};case"boolean":return function(e){const s=t(e);return Number.isNaN(+s)?Boolean(s):!!+s};case"object":return function(e){return JSON.parse(t(e))};case"string":return function(e){return String(t(e))};default:return t}}static parseHeader(e,t){return new DatasetHeader(e,t)}static load(e,t,s){return new Promise(((n,r)=>{fetch(e,s).then((e=>{200===e.status&&e.ok?e.text().then((e=>n(new Dataset(e,t)))).catch(r):r(e)})).catch(r)}))}constructor(e,t={}){const{excluded:s,encoders:n,types:r,slice:{start:o,end:i}={}}=t,[a,...c]=Dataset.readFile(e);this.header=Dataset.parseHeader(a,{types:r,encoders:n}),this.rows=this.parseRows(o||i?c.slice(o||0,i):c,{excluded:s})}get columns(){return this.header.columns}setType(e,t){this.header.setColumnTypeByColumnKey(e,t);const{index:s,type:n}=this.header.getColumnByKey(e);this.rows.forEach((e=>{e[s]=n(e[s])}))}setTypes(e){for(const[t,s]of e)this.setType(t,s)}getColumn(e){if(this.header.hasColumn(e)){const t=this.header.getColumnIndexByColumnKey(e);return this.rows.map((e=>e[t]))}throw new Error}removeColumns(e){const t=Array.isArray(e)?e:[e],s=this.header.removeColumns(t);return new Promise((e=>{this.mapAsync((e=>e.filter(((e,t)=>!s.includes(t))))).then((()=>e(!0)),console.error)}))}parseRows(e,t={}){const{excluded:s}=t,n=[];return s&&n.push(...this.header.removeColumns(s)),e.map((e=>e.filter(((e,t)=>!n.includes(t))).map(((e,t)=>{const{encoder:s,type:n}=this.header.getColumnByIndex(t);return s?s.getEncoded(n(e)):n(e)}))))}encodeColumn(e){const t=this.header.getColumnByKey(e),{index:s,type:n}=t;let{encoder:r}=t;r||(r=this.header.registerColumnEncoderByColumnKey(e));for(const e of this.rows)e[s]=r.getEncoded(n(e[s]));return this.rows}encodeColumns(e){const t=[];for(const s of e){const e=this.header.getColumnByKey(s),{index:n,type:r}=e;let{encoder:o}=e;o||(o=this.header.registerColumnEncoderByColumnKey(s)),o&&n&&t.push([n,r,o])}for(const[e,s,n]of t)for(const t of this.rows)t[e]=n.getEncoded(s(t[e]));return this.rows}encodeCell(e,t){const{type:s,encoder:n}=this.header.getColumnByKey(e);if(n)return t=n.getEncoded(s(t))}encodeCells(e,t){const{type:s,encoder:n}=this.header.getColumnByKey(e);if(n)return t=t.map((e=>n.getEncoded(s(e))))}decodeColumn(e){const{index:t,encoder:s}=this.header.getColumnByKey(e);for(const e of this.rows)e[t]=s.getDecoded(e[t]);return this.rows}decodeColumns(e){const t=[];for(const s of e){const{index:e,encoder:n}=this.header.getColumnByKey(s);n&&t.push([e,n])}for(const[e,s]of t)for(const t of this.rows)t[e]=s.getDecoded(t[e]);return this.rows}decodeCell(e,t){const s=this.header.getColumnEncoderByColumnKey(e);if(s)return t=s.getDecoded(t)}decodeCells(e,t){const s=this.header.getColumnEncoderByColumnKey(e);if(s)return t=t.map((e=>s.getDecoded(e)))}count(e,t){const s=Array.isArray(t)?t:[t],n={},r={};return s.forEach((e=>n[e]=this.header.getColumnIndexByColumnKey(e))),s.forEach((e=>r[e]=[])),this.forEach(((t,s)=>{for(const o in n)Object.is(t[n[o]],e)&&r[o].push(s)})),r[Symbol("target")]=e,r}async countAsync(e,t){const s=Array.isArray(t)?t:[t],n={},r={};return s.forEach((e=>n[e]=this.header.getColumnIndexByColumnKey(e))),s.forEach((e=>r[e]=[])),new Promise((t=>{this.forEachAsync(((t,s)=>{for(const o in n)Object.is(t[n[o]],e)&&r[o].push(s)})).then((()=>{r[Symbol("target")]=e,t(r)}))}))}groupBy(e){return Dataset._groupBy(this.rows,e.some((e=>"string"==typeof e))?e.map((e=>this.header.getColumnIndexByColumnKey(e))):e)}sortBy(e,t=!0){function s(e){if("function"==typeof e)return e;switch(`${e}`.toLowerCase()){case"d":case"desc":case"descending":case"za":case"z-a":return(e,t)=>t-e;default:return(e,t)=>e-t}}let n,r;if("string"==typeof e&&(e=[e]),e.some((e=>"string"==typeof e))&&(e=e.map((e=>"string"==typeof e?[this.header.getColumnIndexByColumnKey(e)]:[e]))),[n,r]=(e.some((([e])=>"string"==typeof e))?e.map((([e,t])=>[this.header.getColumnIndexByColumnKey(e),s(t)])):e.map((([e,t])=>[e,s(t)]))).reduce(((e,t,s)=>(e[0][s]=t[0],e[1].set(t[0],t[1]),e)),[[],new Map]),e.length>1){const e=Dataset._groupBy(this.rows,n),s=Dataset._flat(n,e,{sortFunctionMap:r});return t?(this.rows=s,this.rows):s}const[o]=n;if(r.has(o)){let e;if(e=r.get(o))return t?this.rows.sort(((t,s)=>e(t[o],s[o]))):[...this.rows].sort(((t,s)=>e(t[o],s[o])))}return this.rows}filter(e,t,s=!0){if("function"==typeof e)return this.rows=this.rows.filter(e);let n,r,o;if([n,r]=(e.some((([e])=>"string"==typeof e))?e.map((([e,t])=>[this.header.getColumnIndexByColumnKey(e),t])):e.map((([e,t])=>[e,t]))).reduce(((e,[t,s],n)=>(e[0][n]=t,e[1].set(t,s),e)),[[],new Map]),t&&(o=(t.some((([e])=>"string"==typeof e))?t.map((([e,t])=>[this.header.getColumnIndexByColumnKey(e),t])):t.map((([e,t])=>[e,t]))).reduce(((e,[t,s])=>e.set(t,s)),new Map)),e.length>1){const e=Dataset._groupBy(this.rows,n),t=Dataset._flat(n,e,{filterFunctionMap:r,groupByFilterFunctionMap:o});return s?(this.rows=t,this.rows):t}const[i]=n;if(r.has(i)){const e=r.get(i);if(e){const t=this.rows.filter(e);return s?(this.rows=t,this.rows):t}}return this.rows}forEach(e,t=this.rows){for(let s=0,n=this.rows.length;s<n;s+=1)e(this.rows[s],s,t)}async forEachAsync(e,t=this.rows){for(let s=0,n=this.rows.length;s<n;s+=1)e(this.rows[s],s,t)}map(e,t={}){const{inplace:s,thisArg:n=this.rows}=t;if(s){for(let t=0,s=this.rows.length;t<s;t+=1)this.rows[t]=e(this.rows[t],t,n);return this.rows}const r=[];for(let t=0,s=this.rows.length;t<s;t+=1)r[t]=e(this.rows[t],t,n);return r}async mapAsync(e,t={}){const{inplace:s,thisArg:n=this.rows}=t;if(s){for(let t=0,s=this.rows.length;t<s;t+=1)this.rows[t]=e(this.rows[t],t,n);return this.rows}const r=[];for(let t=0,s=this.rows.length;t<s;t+=1)r[t]=e(this.rows[t],t,n);return r}}export default{Dataset,DatasetEncoder,DatasetHeader};
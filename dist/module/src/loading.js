import{ExtendedWorker as e}from"./multithread.js";import{WebPTest as t}from"./navigator.js";import{getGlobal as r}from"./utils.js";export class Wait{static register(){const e=r();return void 0===e.WaitRegister&&(e.WaitRegister={interactive:[],complete:[],DOMContentLoaded:[],load:[]},document.addEventListener("readystatechange",(()=>Wait.all(document.readyState))),document.addEventListener("DOMContentLoaded",(()=>Wait.all("DOMContentLoaded"))),window.addEventListener("load",(()=>Wait.all("load")))),e.WaitRegister}static set(e,t){const{resolve:r,reject:a,func:s,args:o}=t,i=Wait.register();let n=!1;const{readyState:c}=document;switch(e){case"interactive":case"DOMContentLoaded":if("loading"!==c){n=!0;try{r(s(...o))}catch(e){a(e)}}break;case"complete":case"load":if("complete"===c){n=!0;try{r(s(...o))}catch(e){a(e)}}}!1===n&&i[e].push((()=>new Promise(((e,t)=>{try{return e(r(s(...o)))}catch(e){t(a(e))}}))))}static all(e){return Promise.all(Wait.register()[e].map((e=>e())))}static time(e){return new Promise((t=>setTimeout(t,e)))}static delay(e,t,...r){return setTimeout(e,t||0,...r)}static async(e,...t){return new Promise(((r,a)=>{try{r(e(...t))}catch(e){a(e)}}))}static promiseDelay(e,t,...r){return new Promise(((a,s)=>setTimeout(((...t)=>{try{return a(e(...t))}catch(e){return s(e)}}),t,...r)))}static interactive(e,...t){return new Promise(((r,a)=>{Wait.set("interactive",{resolve:r,reject:a,func:e,args:t})}))}static complete(e,...t){return new Promise(((r,a)=>{Wait.set("complete",{resolve:r,reject:a,func:e,args:t})}))}static DOMContentLoaded(e,...t){return new Promise(((r,a)=>{Wait.set("DOMContentLoaded",{resolve:r,reject:a,func:e,args:t})}))}static ready(e,...t){return new Promise(((r,a)=>{Wait.set("complete",{resolve:r,reject:a,func:e,args:t})}))}static load(e,...t){return new Promise(((r,a)=>{Wait.set("complete",{resolve:r,reject:a,func:e,args:t})}))}}export class ImageLoader{constructor(){this.worker=new e((()=>{self.onmessage=function(e){(function(e,t,r){return r=r&&"object"==typeof r?r:Object.create(null),new Promise((async(a,s)=>{fetch(e,{method:"GET",mode:"cors",credentials:"include",cache:"default",...r}).then((async e=>{if(200===e.status)try{const r=await e.blob();return a([t,URL.createObjectURL(r)])}catch(e){return console.error(e),s([t,""])}return console.error(e),s([t,""])})).catch((e=>(console.error(e),s([t,""]))))}))})(e.data.data.url,e.data.id).then((([e,t])=>{self.postMessage({id:e,data:{url:t||""}})}))}}),{promise:!0})}async load(e={}){const{src:r,webp:a}=e;let s;if(a&&"string"==typeof a){s=await t.passed?(await this.worker.postMessage({url:a})).url:(await this.worker.postMessage({url:r})).url}else s=(await this.worker.postMessage({url:r})).url;return s}static async load(e){const t=r();return"ImageLoader"in t||(t.ImageLoader=new ImageLoader),await t.ImageLoader.load(e)}terminate(){this.worker.terminate()}static terminate(){const e=r();"ImageLoader"in e&&(e.ImageLoader.terminate(),delete e.ImageLoader)}}export default{ImageLoader,Wait};
export const Easing={linearTween:(e,t,n,i)=>n*e/i+t,easeInQuad:(e,t,n,i)=>n*(e/=i)*e+t,easeOutQuad:(e,t,n,i)=>-n*(e/=i)*(e-2)+t,easeInOutQuad:(e,t,n,i)=>(e/=i/2)<1?n/2*e*e+t:-n/2*(--e*(e-2)-1)+t,easeInCubic:(e,t,n,i)=>n*(e/=i)*e*e+t,easeOutCubic:(e,t,n,i)=>(e/=i,n*(--e*e*e+1)+t),easeInOutCubic:(e,t,n,i)=>(e/=i/2)<1?n/2*e*e*e+t:n/2*((e-=2)*e*e+2)+t,easeInQuart:(e,t,n,i)=>n*(e/=i)*e*e*e+t,easeOutQuart:(e,t,n,i)=>(e/=i,-n*(--e*e*e*e-1)+t),easeInOutQuart:(e,t,n,i)=>(e/=i/2)<1?n/2*e*e*e*e+t:-n/2*((e-=2)*e*e*e-2)+t,easeInQuint:(e,t,n,i)=>n*(e/=i)*e*e*e*e+t,easeOutQuint:(e,t,n,i)=>(e/=i,n*(--e*e*e*e*e+1)+t),easeInOutQuint:(e,t,n,i)=>(e/=i/2)<1?n/2*e*e*e*e*e+t:n/2*((e-=2)*e*e*e*e+2)+t,easeInSine:(e,t,n,i)=>-n*Math.cos(e/i*(Math.PI/2))+n+t,easeOutSine:(e,t,n,i)=>n*Math.sin(e/i*(Math.PI/2))+t,easeInOutSine:(e,t,n,i)=>-n/2*(Math.cos(Math.PI*e/i)-1)+t,easeInExpo:(e,t,n,i)=>n*2**(10*(e/i-1))+t,easeOutExpo:(e,t,n,i)=>n*(1-2**(-10*e/i))+t,easeInOutExpo:(e,t,n,i)=>(e/=i/2)<1?n/2*2**(10*(e-1))+t:n/2*(2-2**(-10*--e))+t,easeInCirc:(e,t,n,i)=>(e/=i,-n*(Math.sqrt(1-e*e)-1)+t),easeOutCirc:(e,t,n,i)=>(e/=i,e--,n*Math.sqrt(1-e*e)+t),easeInOutCirc:(e,t,n,i)=>(e/=i/2)<1?-n/2*(Math.sqrt(1-e*e)-1)+t:(e-=2,n/2*(Math.sqrt(1-e*e)+1)+t)};export function div(e,t,n=100){function i(e,t){1e3===e.decimal[o].length&&(e.decimal.push([]),o+=1),e.decimal[o].push(t),n-=1}const a=BigInt(e),r=BigInt(t);if(0n===r)return 1/0;const u=a/r,s=a-r*u;let o=0;const c={integer:0n,decimal:[[]]};if(c.integer=u,Object.defineProperty(c,"toString",{value:function(){return this.decimal.length>0?`${this.integer}.${this.decimal.map((e=>e instanceof Array?e.join(""):e)).join("")}`.replace(/n/g,""):`${this.integer}`}}),0n===s)return c;let I=10n*s;for(;n>0&&0n!==I;){const e=I/r,t=I-e*r;if(i(c,Number(e)),!(t>0)){i(c,Number(e));break}I=t,I<r&&(I*=10n)}return c}export function mul(e,t){return BigInt(e)*BigInt(t)}export function fact(e){let t=BigInt(e);if(t<0n)throw new Error;let n=1n;for(;t>0n;t-=1n)n*=t;return n}export function pow(e,t){return BigInt(e)**BigInt(t)}export function fib(e){let t=0n,n=1n;for(let i=2;i<=e;i+=1)[t,n]=[n,t+n];return t}export default{Easing,div,mul,pow,fact,fib};